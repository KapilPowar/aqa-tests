#!groovy

timestamps{
    stage('Setup') {

            def SYNC_LABEL = params.SYNC_LABEL ?: "ci.role.test&&hw.arch.x86&&sw.os.linux"
            println "SYNC_LABEL: ${SYNC_LABEL}"
            node(SYNC_LABEL) {
                echo "clone the SCM GIT repo"
                try {
                    def gitConfig = scm.getUserRemoteConfigs().get(0)
                    // Adopt windows machines require env here https://github.com/adoptium/aqa-tests/issues/1803
                    // ref_cache = "${env.HOME}/openjdk_cache"
                    timeout(time: 1, unit: 'HOURS') {
                        forceCleanWS()
                    }
                    checkout scm: [$class: 'GitSCM',
                    branches: [[name: "${scm.branches[0].name}"]],
                    extensions: [
                        [$class: 'CleanBeforeCheckout'],
                        [$class: 'CloneOption'],// reference: ref_cache],
                        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'aqa-tests']],
                    userRemoteConfigs: [[url: "${gitConfig.getUrl()}"]]
                    ]
                    callScripts()
                } catch (Exception e) {
                    println("Exception: " + e.toString())
                    // build result may not be updated correctly at the moment (see https://issues.jenkins.io/browse/JENKINS-56402)
                    // if there is an exception, set currentBuild.result to ABORTED/FAILURE
                    if (e.toString().contains("FlowInterruptedException")) {
                        println("Exception: " + e.toString())
                        currentBuild.result = 'ABORTED'
                    } else {
                        println("Exception: " + e.toString())
                        currentBuild.result = 'FAILURE'
                    }
                }
            }
    }
}

def forceCleanWS() {
    try {
        cleanWs disableDeferredWipeout: true, deleteDirs: true
    } catch (Exception e) {
        echo 'Exception: ' + e.toString()
        //cleanWs has issue to delete workspace that contains non-ASCII filename in TKG output https://issues.jenkins.io/browse/JENKINS-33478
        //cannot delete workspace directly. Otherwise, Jenkins job will abort due to missing workspace
        sh "rm -rf ${env.WORKSPACE}/aqa-tests/TKG"
        // call cleanWs() again
        cleanWs disableDeferredWipeout: true, deleteDirs: true
    }
}

def getJavaSDK(){
    def JDK_VERSION_OPTION = params.JDK_VERSION ? "-j ${params.JDK_VERSION}" : ""
    def CUSTOMIZED_SDK_URL_OPTION = "-c ${params.CUSTOMIZED_SDK_URL}"
    def CLONE_OPENJ9_OPTION = "--clone_openj9 false"
    def PLATFORM_OPTION = "-p x86-64_linux"
    def GET_SH_CMD = "./get.sh -s `pwd`/.. ${PLATFORM_OPTION} ${JDK_VERSION_OPTION} ${CUSTOMIZED_SDK_URL_OPTION} ${CLONE_OPENJ9_OPTION} "
    dir("${WORKSPACE}/aqa-tests") {
        if (params.CUSTOMIZED_SDK_URL_CREDENTIAL_ID) {
			withCredentials([usernamePassword(credentialsId: "${params.CUSTOMIZED_SDK_URL_CREDENTIAL_ID}", usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
			sh "$GET_SH_CMD"
			}
		} else {
			sh "$GET_SH_CMD"
		}
    }
}

def callScripts(){
        getJavaSDK()
        def SCRIPT_PR=targetFolderCheck()
        echo "SCRIPT_PR in jcysync-- ${SCRIPT_PR}"
        SCRIPT_PR=getSplitter(SCRIPT_PR)
        echo "SCRIPT_PR after splitter-- ${SCRIPT_PR}"
        if (SCRIPT_PR){
            createPRForScripts()
        }
}

def targetFolderCheck(){
    stage('FolderCheck') {
    env.TEST_JDK_HOME = "$WORKSPACE/openjdkbinary/j2sdk-image"
    echo "TEST_JDK_HOME == ${env.TEST_JDK_HOME}"
    def logFile = "test.log"
    def COMMENT=""
    def SCRIPT_PR = false
    dir("${WORKSPACE}/aqa-tests/jck/jck_target_folder_check") {
                sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true){
                    def JCK_GIT_BRANCH = params.JCK_GIT_BRANCH ?: "autoBranch" //default branch name in jckupdater.sh
                    //echo "${GIT_BRANCH}"
                    def SCRIPT = "./jck_target_folder_check.sh ${params.JCK_GIT_REPO} ${WORKSPACE} ${JCK_GIT_BRANCH}"
                    def specificLine = "New test folder detected:"

                    def STATUS = sh(script: "${SCRIPT} >${logFile}", returnStatus: true)
                    echo "EXITCODE for jck_target_folder_check = ${STATUS}"
                    sh "cat ${logFile}"
                        
                    // Use 'grep' to check if any new folders are detected
                    def grepCommand = "grep '${specificLine}' ${logFile}"
                    def grepResult = sh(script: grepCommand, returnStatus: true, returnStdout: true)
                    echo "grepResult -- $grepResult"
                    // grep last few lines after Done! to create comment
                    def fileContents = readFile(file: logFile).trim()
                    def delimiter = 'Done!'
                    def parts = fileContents.split(delimiter)
                    def linesAfterDone = parts[1].trim()
                    def lines = linesAfterDone.split('\n')
                    def commentBody = lines.collect { it.trim() }.join('\\r\\n')

                    if (grepResult == 0)  {
                        echo "New folders detected. Need to update playlist.xml'"
                        COMMENT="New folders detected. Need to update playlist.xml \\r\\n ``` ${commentBody} "
                        SCRIPT_PR=udpateFolderCheck(logFile)
                    } else {
                        echo "No new folders detected. No need to update playlist.xml '"
                        COMMENT="No new folders detected. No need to update playlist.xml \\r\\n ``` ${commentBody} "
                    }
                }
            }
            createComment(COMMENT)
            echo "SCRIPT_PR --  $SCRIPT_PR"
            return SCRIPT_PR
    }
}
def udpateFolderCheck(file){

    def ADOPTIUM_GIT_USER = params.ADOPTIUM_GIT_USER ?: ""

    if (ADOPTIUM_GIT_USER == "" || ADOPTIUM_GIT_USER == null){
        echo "No PR will be created as ADOPTIUM_GIT_USER value is null. "
        return false
    } else {
        dir("${WORKSPACE}/aqa-tests/jck") {
                def logfile="${WORKSPACE}/aqa-tests/jck/jck_target_folder_check/$file"
                echo "logfile path -- $logfile"
                
                def SCRIPT = "./jck_target_folder_check/update_jck_target_folder.sh ${WORKSPACE}/aqa-tests/jck $logfile"
                STATUS = sh(script: "${SCRIPT}",  returnStatus: true)    
                if (STATUS == 0){
                    def commit="update folder check "
                    def filepath='**/playlist.xml' 
                    pushChangesToRepo(commit, filepath,false)
                } else {
                    echo "Update_jck_target_folder script resulted non zero return status."
                    return false
                }
        }
    return true
    }
}

def getSplitter(script_pr){
    stage('Splitter') {
    dir("${WORKSPACE}/aqa-tests/jck/splitter") {
        def JDK_VERSION= params.JDK_VERSION
        if (JDK_VERSION == "8") {
            JDK_VERSION = "8d"
        } else if (JDK_VERSION == "11"){
             JDK_VERSION = "11a"
        }
        def tempOutputFile = "SplitterOutput.txt"
        def SCRIPT = "./testUpdater.sh ${WORKSPACE} ${JDK_VERSION}"
        def response = sh(script: "${SCRIPT} > ${tempOutputFile}",  returnStatus: true)
        def scriptOutput = readFile(tempOutputFile).trim()
        def COMMENT=""
        echo scriptOutput
        if (scriptOutput =~ /PR_NEEDED=true/){
            def match = (scriptOutput =~ /Class_List=(.*)/)
            def testClassList = match[0][1].split()
            echo "testClassList -- ${testClassList}"
            COMMENT=" Splitter.sh resulted in new test groups.\\r\\n We need to create PR to update jck.mk file for below test group\\r\\n " 
            COMMENT+=testClassList.join(',')
            filepath= "${WORKSPACE}/aqa-tests/jck/jck${JDK_VERSION}.mk"
            commit= "update jck.mk"
            pushChangesToRepo(commit,filepath,script_pr)
            script_pr=true
        } else {
            COMMENT =" No need to create PR to update jck.mk file."
        }
        createComment(COMMENT)
        return script_pr
    }
}
}

def pushChangesToRepo(commit,target,script_pr){
    def ADOPTIUM_GIT_USER = params.ADOPTIUM_GIT_USER ?: ""

    if (ADOPTIUM_GIT_USER == "" || ADOPTIUM_GIT_USER == null){
        echo "No PR will be created as ADOPTIUM_GIT_USER value is null. "
        return false
    } else {
        sshagent(credentials:["${params.ADOPTIUM_SSH_CREDS}"], ignoreMissing: true){
            dir("${WORKSPACE}/aqa-tests/jck") {
                if (!script_pr){
                    try {
                        sh """
                            git remote remove origin
                            git remote remove upstream
                        """
                    } catch (Exception e) {
                        echo "Error removing remote: ${e.message}"
                    }
                    def origin ="git@github.com:${ADOPTIUM_GIT_USER}/aqa-tests.git"
                    def upstream ="git@github.com:adoptium/aqa-tests.git"
                    sh """
                        git remote add origin ${origin}
                        git remote add upstream ${upstream}
                        git fetch upstream
                        git checkout -b autoTest
                        git config --global user.email "${ADOPTIUM_GIT_USER}@in.ibm.com"
                        git config --global user.name "${ADOPTIUM_GIT_USER}"
                    """
                }
                //git checkout -b personal-branch upstream/main
            sh """
                git add ${target}
                git commit -m \"${commit}\"
                git push origin autoTest
            """
            }
        }
    }
}

def createPRForScripts() {
    stage('CreatePR') {
    def ADOPTIUM_GIT_USER = params.ADOPTIUM_GIT_USER ?: ""
    if (ADOPTIUM_GIT_USER == ""){
        echo "No PR will be created as ADOPTIUM_GIT_USER value is null. "
    } else {
        withCredentials([
                string(credentialsId: "${params.ADOPTIUM_GIT_CREDENTIALS}",variable: 'ADOPTIUM_GIT_TOKEN')
            ]){
            dir("${WORKSPACE}/aqa-tests") {
                sshagent(credentials:["${params.ADOPTIUM_SSH_CREDS}"], ignoreMissing: true){
                title="Update jck.mk and playlist.xml file"
                body="Creating PR to update jck.mk and playlist file"
                echo " Creating PR for jck.mk and playlist.xml file"
                url="https://api.github.com/repos/${ADOPTIUM_GIT_USER}/aqa-tests/pulls"
                //-d "{"title":"$title","body":"$body","head":\"KapilPowar:test\",\"base\":\"jcksync-copy"}" \
                //change base branch to adoptium main branch
                def CURL_COMMAND = """
                                    curl -X POST "${url}" \\
                                        -H "Authorization: token \"\$ADOPTIUM_GIT_TOKEN\"" \\
                                        -H "Content-Type: application/json" \\
                                        -d '{
                                            "title": "${title}",
                                            "body": "${body}",
                                            "head": "${ADOPTIUM_GIT_USER}:autoTest",
                                            "base": "jcksync-copy"
                                        }'
                                """
                def response = sh(script: CURL_COMMAND, returnStdout: true)
                def matcher = (response =~ /"number":\s*(\d+)/)
                def PR = matcher ? matcher[0][1] : null
                echo "PR_NUMBER = ${PR}"
                PR_URL= "https://github.com/${ADOPTIUM_GIT_USER}/aqa-tests/pull/"
                COMMENT=" PR #[${(PR)}](${PR_URL}${(PR)})  is created with changes in jck.mk and playlist.xml file .. "
                createComment(COMMENT)
                }
            }
        }
    }
}
}

def createComment(comment) {
    withCredentials([
        string(credentialsId: "${params.GIT_CREDENTIALS}",variable: 'GIT_CREDENTIALS')
    ]) {
        def PR_NUMBER = params.PR_NUMBER ?:0
        if (PR_NUMBER == 0){
            echo "No PR created to comment"
        }else{
            def DOMAIN = params.JCK_GIT_REPO.split(/[@:]/)
            def REPO = DOMAIN[2].split('\\.')
            def COMMENT_URL="https://${DOMAIN[1]}/api/v3/repos/${REPO[0]}/issues/${PR_NUMBER}/comments"
            def PR_URL="https://${DOMAIN[1]}/${REPO[0]}/pull/${PR_NUMBER}"
            echo ("${comment}")
            def CURL_COMMAND = """
                curl -X POST -H "Authorization: token \"\$GIT_CREDENTIALS\"" \\
                -d '{
                "body":"${comment}"
                }' "$COMMENT_URL"
            """
            def STATUS = sh(script: CURL_COMMAND, returnStatus: true, returnStdout: true)
            if (STATUS == 0) {
                echo ("Comment added successfully to PR ${PR_URL} ")
            } else {
                error ("Failed to add a comment to PR ${PR_URL} ")
            }
        }
    }
}
