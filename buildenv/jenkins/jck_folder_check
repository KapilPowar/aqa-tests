#!groovy

timestamps{
    stage('Setup') {
        def SYNC_LABEL = params.SYNC_LABEL ?: "ci.role.test&&hw.arch.x86&&sw.os.linux"
        println "SYNC_LABEL: ${SYNC_LABEL}"
        node(SYNC_LABEL) {
            echo "clone the SCM GIT repo"
            try {
                def gitConfig = scm.getUserRemoteConfigs().get(0)
                // Adopt windows machines require env here https://github.com/adoptium/aqa-tests/issues/1803
                // ref_cache = "${env.HOME}/openjdk_cache"
                timeout(time: 1, unit: 'HOURS') {
                    forceCleanWS()
                }
                checkout scm: [$class: 'GitSCM',
                branches: [[name: "${scm.branches[0].name}"]],
                extensions: [
                    [$class: 'CleanBeforeCheckout'],
                    [$class: 'CloneOption'],// reference: ref_cache],
                    [$class: 'RelativeTargetDirectory', relativeTargetDir: 'aqa-tests']],
                    userRemoteConfigs: [[url: "${gitConfig.getUrl()}"]]
                ]
                getJavaSDK()
                def scriptPR = targetFolderCheck()
                scriptPR = getSplitter(scriptPR)
                if (scriptPR){
                    createPRForScripts()
                }
            } catch (Exception e) {
                println("Exception: " + e.toString())
                // build result may not be updated correctly at the moment (see https://issues.jenkins.io/browse/JENKINS-56402)
                    // if there is an exception, set currentBuild.result to ABORTED/FAILURE
                if (e.toString().contains("FlowInterruptedException")) {
                    println("Exception: " + e.toString())
                    currentBuild.result = 'ABORTED'
                } else {
                    println("Exception: " + e.toString())
                    currentBuild.result = 'FAILURE'
                }
            } finally {
                    timeout(time: 1, unit: 'HOURS') {
                        forceCleanWS()
                    }
            }
        }
    }
}

def forceCleanWS() {
    try {
        cleanWs disableDeferredWipeout: true, deleteDirs: true
    } catch (Exception e) {
        echo 'Exception: ' + e.toString()
        //cleanWs has issue to delete workspace that contains non-ASCII filename in TKG output https://issues.jenkins.io/browse/JENKINS-33478
        //cannot delete workspace directly. Otherwise, Jenkins job will abort due to missing workspace
        sh "rm -rf ${env.WORKSPACE}/aqa-tests/TKG"
        // call cleanWs() again
        cleanWs disableDeferredWipeout: true, deleteDirs: true
    }
}

def getJavaSDK(){
    def JDK_VERSION_OPTION = params.JDK_VERSION ? "-j ${params.JDK_VERSION}" : ""
    def CUSTOMIZED_SDK_OPTION = "-c ${params.CUSTOMIZED_SDK}"
    def CLONE_OPENJ9_OPTION = "--clone_openj9 false"
    def PLATFORM_OPTION = "-p x86-64_linux"
    def GET_SH_CMD = "./get.sh -s `pwd`/.. ${PLATFORM_OPTION} ${JDK_VERSION_OPTION} ${CUSTOMIZED_SDK_OPTION} ${CLONE_OPENJ9_OPTION} "
    dir("${WORKSPACE}/aqa-tests") {
        if (params.CUSTOMIZED_SDK_URL_CREDENTIAL_ID) {
			withCredentials([usernamePassword(credentialsId: "${params.CUSTOMIZED_SDK_URL_CREDENTIAL_ID}", usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
			sh "$GET_SH_CMD"
			}
		} else {
			sh "$GET_SH_CMD"
		}
    }
}

def targetFolderCheck(){
    stage('FolderCheck') {
    env.TEST_JDK_HOME = "$WORKSPACE/openjdkbinary/j2sdk-image"
    echo "TEST_JDK_HOME == ${env.TEST_JDK_HOME}"
    def logFile = "test.log"
    def comment=""
    def scriptPR = false
    dir("${WORKSPACE}/aqa-tests/jck/jck_target_folder_check") {
        sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true){
            def JCK_GIT_BRANCH = params.JCK_GIT_BRANCH ?: "autoBranch" //default branch name in jckupdater.sh
            def SCRIPT = "./jck_target_folder_check.sh ${params.JCK_GIT_REPO} ${WORKSPACE} ${JCK_GIT_BRANCH}"
            def specificLine = "New test folder detected:"

            def STATUS = sh(script: "${SCRIPT} >${logFile}", returnStatus: true)
            echo "EXITCODE for jck_target_folder_check = ${STATUS}"
            sh "cat ${logFile}"
                        
            // Use 'grep' to check if any new folders are detected
            def grepCommand = "grep '${specificLine}' ${logFile}"
            def grepResult = sh(script: grepCommand, returnStatus: true, returnStdout: true)
            // grep last few lines after Done! to create comment
            def fileContents = readFile(file: logFile).trim()
            def delimiter = 'Done!'
            def parts = fileContents.split(delimiter)
            def linesAfterDone = parts[1].trim()
            def lines = linesAfterDone.split('\n')
            def commentBody = lines.collect { it.trim() }.join('\\r\\n')

            if (grepResult == 0)  {
                echo "New folders detected. Need to update playlist.xml'"
                //comment="New folders detected. Need to update playlist.xml \\r\\n ``` ${commentBody} "
                scriptPR = udpateFolderCheck(logFile)
            } else {
                echo "No new folders detected. No need to update playlist.xml '"
                //comment="No new folders detected. No need to update playlist.xml \\r\\n ``` ${commentBody} "
                }
            }
        }
        //createComment(comment)
        return scriptPR
    }
}
def udpateFolderCheck(file){
    def ADOPTIUM_GIT_USER = params.ADOPTIUM_GIT_USER ?: ""
    if (ADOPTIUM_GIT_USER == "" || ADOPTIUM_GIT_USER == null){
        echo "No PR will be created as ADOPTIUM_GIT_USER value is null. "
        return false
    } else {
        dir("${WORKSPACE}/aqa-tests/jck") {
            def logfile="${WORKSPACE}/aqa-tests/jck/jck_target_folder_check/$file"
            def SCRIPT = "./jck_target_folder_check/update_jck_target_folder.sh ${WORKSPACE}/aqa-tests/jck $logfile"
            STATUS = sh(script: "${SCRIPT}",  returnStatus: true)    
            if (STATUS == 0){
                def commit="update folder check "
                def filePath='**/playlist.xml' 
                scriptPR = pushChangesToRepo(commit, filePath,false)
            } else {
                echo "Update_jck_target_folder script resulted non zero return status."
                return false
            }
        }
    return true
    }
}

def getSplitter(scriptPR){
    stage('Splitter') {
        dir("${WORKSPACE}/aqa-tests/jck/splitter") {
            def JDK_VERSION= params.JDK_VERSION
            def tempOutputFile = "SplitterOutput.txt"
            def SCRIPT = "./testUpdater.sh ${WORKSPACE} ${JDK_VERSION}"
            def response = sh(script: "${SCRIPT} > ${tempOutputFile}",  returnStatus: true)
            def scriptOutput = readFile(tempOutputFile).trim()
            def comment=""
            echo scriptOutput
            if (scriptOutput =~ /PR_NEEDED=true/){
                // def match = (scriptOutput =~ /Class_List=(.*)/)
                // def testClassList = match[0][1].split()
                // echo "Splitter.sh resulted in new test groups. We need to create PR to update jck.mk file for below test group\n "+ testClassList.join(',')
                filePath= "${WORKSPACE}/aqa-tests/jck/subdirs/jck${JDK_VERSION}.mk"
                commit= "update jck.mk"
                scriptPR = pushChangesToRepo(commit,filePath,scriptPR)
            } else {
                echo " No need to create PR to update jck.mk file."
            }
            //createComment(comment)
            return scriptPR
        }
    }
}

def pushChangesToRepo(commit,target,scriptPR){
    def ADOPTIUM_GIT_USER = params.ADOPTIUM_GIT_USER ?: ""

    if (ADOPTIUM_GIT_USER == "" || ADOPTIUM_GIT_USER == null){
        echo "No PR will be created as ADOPTIUM_GIT_USER value is null. "
        return false
    } else {
        sshagent(credentials:["${params.ADOPTIUM_SSH_CREDS}"], ignoreMissing: true){
            dir("${WORKSPACE}/aqa-tests/jck") {
                if (!scriptPR){
                    try {
                        sh """
                            git remote remove origin
                            git remote remove upstream
                        """
                    } catch (Exception e) {
                        echo "Error removing remote: ${e.message}"
                    }
                    def origin ="git@github.com:${ADOPTIUM_GIT_USER}/aqa-tests.git"
                    def upstream ="git@github.com:adoptium/aqa-tests.git"
                    sh """
                        git remote add origin ${origin}
                        git remote add upstream ${upstream}
                        git fetch upstream
                        git checkout -b autoTest
                        git config --global user.email "${ADOPTIUM_GIT_USER}@in.ibm.com"
                        git config --global user.name "${ADOPTIUM_GIT_USER}"
                    """
                }
                //git checkout -b personal-branch upstream/main
            sh """
                git add ${target}
                git commit -m \"${commit}\"
                git push origin autoTest
            """
            }
        }
    return true
    }
}

def createPRForScripts() {
    stage('CreatePR') {
        def ADOPTIUM_GIT_USER = params.ADOPTIUM_GIT_USER ?: ""
        if (ADOPTIUM_GIT_USER == ""){
            echo "No PR will be created as ADOPTIUM_GIT_USER value is not provided. "
        } else {
            withCredentials([
                string(credentialsId: "${params.ADOPTIUM_GIT_CREDENTIALS}",variable: 'ADOPTIUM_GIT_TOKEN')
            ]){
                dir("${WORKSPACE}/aqa-tests") {
                    sshagent(credentials:["${params.ADOPTIUM_SSH_CREDS}"], ignoreMissing: true){
                    title="Update jck.mk and playlist.xml file"
                    body="Creating PR to update jck.mk and playlist file"
                    echo " Creating PR for jck.mk and playlist.xml file"
                    url="https://api.github.com/repos/${ADOPTIUM_GIT_USER}/aqa-tests/pulls"
                    //-d "{"title":"$title","body":"$body","head":\"KapilPowar:test\",\"base\":\"jcksync-copy"}" \
                    //change base branch to adoptium main branch
                    def CURL_COMMAND = """
                        curl -X POST -H 'Authorization: token \"\$ADOPTIUM_GIT_TOKEN\"' \\
                        -H "Content-Type: application/json" \\
                        -d '{
                            "title": "${title}",
                            "body": "${body}",
                            "head": "${ADOPTIUM_GIT_USER}:autoTest",
                            "base": "jcksync-copy"
                        }' "${url}"
                    """
                    def response = sh(script: CURL_COMMAND, returnStdout: true)
                    def matcher = (response =~ /"number":\s*(\d+)/)
                    def prNumber = matcher ? matcher[0][1] : null
                    prURL= "https://github.com/${ADOPTIUM_GIT_USER}/aqa-tests/pull/"
                    comment=" PR #[${(prNumber)}](${prURL}${(prNumber)}) is created with changes in jck.mk and playlist.xml file .. "
                    echo "${comment}"
                    }
                }
            }
        }
    }
}
