#!groovy

def PR=0
//def COMMENT = ""
def EXITCODE = 0
def SCRIPT_PR = false
timestamps{
    stage('Setup') {
            //SPEC = "linux_x86-64"
            if (params.LABEL) {
                LABEL = params.LABEL
            } else {
                LABEL = "ci.role.test&&hw.arch.x86&&sw.os.linux"
            }
            node(LABEL) {
                echo "clone the SCM GIT repo"
               // println "SPEC: ${SPEC}"
                println "LABEL: ${LABEL}"
                try {
                    def gitConfig = scm.getUserRemoteConfigs().get(0)
                    // Adopt windows machines require env here https://github.com/adoptium/aqa-tests/issues/1803
                    // ref_cache = "${env.HOME}/openjdk_cache"
                    // timeout(time: 1, unit: 'HOURS') {
                    //     forceCleanWS()
                    // }
                    checkout scm: [$class: 'GitSCM',
                    branches: [[name: "${scm.branches[0].name}"]],
                    extensions: [
                        [$class: 'CleanBeforeCheckout'],
                        [$class: 'CloneOption'],// reference: ref_cache],
                        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'aqa-tests']],
                    userRemoteConfigs: [[url: "${gitConfig.getUrl()}"]]
                    ]
                    syncJckMaterial()

                } catch (Exception e) {
                    println("Exception: " + e.toString())
                    // build result may not be updated correctly at the moment (see https://issues.jenkins.io/browse/JENKINS-56402)
                    // if there is an exception, set currentBuild.result to ABORTED/FAILURE
                    if (e.toString().contains("FlowInterruptedException")) {
                        currentBuild.result = 'ABORTED'
                    } else {
                        currentBuild.result = 'FAILURE'
                    }
                } finally {
                        timeout(time: 15, unit: 'MINUTES') {
                            if (currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                                echo "Build was successful."
                                currentBuild.result = "SUCCESS"
                            } else if (currentBuild.resultIsWorseOrEqualTo('FAILURE')) {
                                echo "Build failed."
                                currentBuild.result = "FAILED"
                            } else {
                                echo "Build status is unknown or unstable."
                                currentBuild.result = "UNSTABLE"
                            }
                            def build_status=("${env.JOB_NAME} #${env.BUILD_NUMBER} result is $currentBuild.result .")
                            println "$build_status"
                            //createComment(build_status)
                        }
                }
            }
    }
}

def forceCleanWS() {
    try {
        cleanWs disableDeferredWipeout: true, deleteDirs: true
    } catch (Exception e) {
        echo 'Exception: ' + e.toString()
        //cleanWs has issue to delete workspace that contains non-ASCII filename in TKG output https://issues.jenkins.io/browse/JENKINS-33478
        //cannot delete workspace directly. Otherwise, Jenkins job will abort due to missing workspace
        sh "rm -rf ${env.WORKSPACE}/aqa-tests/TKG"
        // call cleanWs() again
        cleanWs disableDeferredWipeout: true, deleteDirs: true
    }
}

def syncJckMaterial(){
        echo "Starting script to sync JCK materials ....."
        def JCK_VERSION = params.JDK_VERSION ? "-j ${params.JDK_VERSION}": ""
        def JCK_GIT_BRANCH = params.JCK_GIT_BRANCH ? "-gb ${params.JCK_GIT_BRANCH}": ""
       // def JAVA_HOME = params.JAVA_HOME ? "-java ${params.JAVA_HOME}": ""
        def ARTIFACTORY_URL = params.ARTIFACTORY_URL ? "-au ${params.ARTIFACTORY_URL}": ""
        def JCK_GIT_REPO = params.JCK_GIT_REPO ? "-repo ${params.JCK_GIT_REPO}": ""
        //def EXITCODE = 1

        stage('Build') {
                script {
                    getJavaSDK()
                    udpateFolderCheck()
                    withCredentials([
                        usernamePassword(credentialsId: "${params.ARTIFACTORY_CREDENTIALS}",
					usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_CREDENTIALS'),
                        string(credentialsId: "${params.GIT_CREDENTIALS}",variable: 'GIT_CREDENTIALS')
                    ]) {
                            def currentDirectory = sh(script: 'pwd', returnStdout: true).trim()
                            dir("${currentDirectory}/aqa-tests/jck/jck-semiauto-updater") {
                                sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true){
                                    def SCRIPT = "./jckupdater.sh ${JCK_VERSION} -at ${ARTIFACTORY_CREDENTIALS} ${JCK_GIT_REPO}  -gt ${GIT_CREDENTIALS}  ${ARTIFACTORY_URL}  ${JCK_GIT_BRANCH} "
                                    echo "${SCRIPT}"
                                    def tempOutputFile = "temp_output.txt"
                                    //create a temp output file 
                                    //tempOutputFile.text  = "This is the content you want to write to the file."
                                    //def scriptOutput = sh(script: "${SCRIPT} > ${tempOutputFile}",  returnStdout: true)
                                    EXITCODE = sh(script: "${SCRIPT} > ${tempOutputFile}",  returnStatus: true)
                                    //EXITCODE = sh(script: "echo \$?", returnStatus: true)
                                    echo "EXITCODE= ${EXITCODE}"
                                    def scriptOutput = readFile(tempOutputFile).trim()
                                    //def output = scriptOutput.trim()
                                    echo "jckupdater script output:"
                                    echo scriptOutput
                                    if (EXITCODE == 2) {
                                        echo "script returned exit code 2, No new update available. Marking the job as SUCCESS. "
                                    } else if (EXITCODE == 0) {
                                        echo "script returned exit code 0, new update is available and PR is created, proceeding to Stage 2."
                                        PR = extractNumber(scriptOutput)
                                        echo "PR created with number : $PR"
                                    } else {
                                        error("script failed with exit code ${EXITCODE}")
                                    }
                                }
                            }
                        }
                    }
                }

        stage( 'Splitter'){
            script{
                if (EXITCODE ==0){
                    target_Folder_check()
                    getSplitter()
                    if (SCRIPT_PR){
                        echo " Need to create PR ? -- $SCRIPT_PR"
                        create_PR_for_scripts()
                    }
                }
            }
        }

        stage('SanityTest') {
               script{
                   if (EXITCODE ==2){ //change it to zero if want to run tests
                    def TEST_PLATFORM="x86-64_linux"
                    def PLATFORMS = TEST_PLATFORM.trim().split("\\s*,\\s*");
                    def CHILD_JOB_NAME="Grinder_JCK"
                    def testJobs = [:]
                    def buildNumbers = [:]
                    def buildResults = [:]
                    //def build_url="https://hyc-runtimes-jenkins.swg-devops.com/job/Grinder_JCK/"
                    def build_url="${JENKINS_URL}/job/${CHILD_JOB_NAME}/"
                    PLATFORMS.each { PLATFORM ->
                    def childParams = []
                    // loop through all the params and change the parameters if needed
                    params.each { param ->
                        if (param.key == "PLATFORM") {
                            childParams << string(name: param.key, value: PLATFORM)
                        // } else if (param.key == "JDK_VERSION") {
                        //     childParams << string(name: param.key, value: JDK_VERSION)
                        // } else if (param.key == "JDK_IMPL") {
                        //     childParams << string(name: param.key, value: JDK_IMPL)
                         } else {
                            def value = param.value.toString()
                            if (value == "true" || value == "false") {
                                childParams << booleanParam(name: param.key, value: value.toBoolean())
                            } else {
                                childParams << string(name: param.key, value: value)
                            }
                        }
                    }
                    
                    testJobs["openjdk${JDK_VERSION}_${PLATFORM}"] = {
                        def buildInfo = build job: CHILD_JOB_NAME, parameters: childParams
                        // Store the build number in the map
                        buildNumbers[PLATFORM] = buildInfo.number
                        buildResults[PLATFORM] = buildInfo.result
                    }
                }
                parallel testJobs
                def COMMENT=""
                //echo "JENKINS_URL--- ${JENKINS_URL}"
                PLATFORMS.each { PLATFORM ->
                    //echo "going to print status and job number "
                    echo "Job openjdk${JDK_VERSION}_${PLATFORM} (Build ${buildNumbers[PLATFORM]}) completed with status: ${buildResults[PLATFORM]}"
                    COMMENT= COMMENT +"Job [${PLATFORM} #${buildNumbers[PLATFORM]}](${build_url}${buildNumbers[PLATFORM]}) completed with status: ${buildResults[PLATFORM]}\\r\\n"
                }
                createComment(COMMENT)
            }
        }
    }
}

def getSplitter(){
    dir("${WORKSPACE}/aqa-tests/jck/splitter") {
        def JDK_VERSION= params.JDK_VERSION
        if (JDK_VERSION == "8") {
            JDK_VERSION = "8d"
        } else if (JDK_VERSION == "11"){
             JDK_VERSION = "11a"
        } 
        def TESTS_MAP = [
            'ANNOT': ['GROUP' : 5,],
            'CLSS' : ['GROUP' : 10,],
            'CONV' : ['GROUP' : 5,],
            'DASG' : ['GROUP' : 5,],
            'EXPR' : ['GROUP' : 11,],
            'INTF' : ['GROUP' : 5,],
            'LMBD' : ['GROUP' : 5,],
            'NAME' : ['GROUP' : 5,],
            'TYPE' : ['GROUP' : 5,],
            'STMT' : ['GROUP' : 5,],
        ]
        def TARGET_TO_SPLIT = "${WORKSPACE}/test/JCK-compiler-${JDK_VERSION}/tests/lang"
        def SCRIPT=""
        def COMMENT=""
        def PR_NEEDED = false
        def testClasstList = []
        def mkFileName = "${WORKSPACE}/aqa-tests/jck/jck.mk"
        TESTS_MAP.each { key, value ->
            if (value.containsKey('GROUP')) {
                //def testsValue = value['TESTS']
                def groupValue = value['GROUP']
                echo "Calling splitter.sh for TESTS: $key and GROUP:$groupValue"
                // Call the test.sh script here, passing testsValue as an argument
                TARGET="${TARGET_TO_SPLIT}/${key}"
                SCRIPT = "./splitter.sh ${TARGET} ${groupValue}"
                if (key == "CLSS"){
                    key="CLASS"
                }
                def logFileName = "${key}.log"
                def EXITCODE = sh(script: "${SCRIPT} > ${logFileName}", returnStatus: true)
                
                echo "EXITCODE in splitter =${EXITCODE}"
                //sh "cat ${logFileName}"
                
                def lastLine = null
                // Read the last line starting with COMPILER_LANG_ANNOT_TESTS_GROUP from logFileName.log
                def logFileContents = readFile(file: logFileName).trim().split('\n')
                for (int i = logFileContents.size() - 1; i >= 0; i--) {
                    def line = logFileContents[i]
                    if (line.startsWith("COMPILER_LANG_${key}_TESTS_GROUP")) {
                        lastLine = line
                        break
                    }
                }
                // Check if the last line is present in jck.mk
                def mkFileContents = readFile(file: mkFileName).trim()
                //echo "Last test group in ${logFileName}: ${lastLine}"
                if (lastLine && mkFileContents.contains(lastLine)) {
                    //echo "The line is present in $mkFileName"
                    echo "No need to create PR for --- $key"
                } else {
                    //echo "The line is not present in $mkFileName"
                    echo "We need to update $mkFileName and create PR for --- $key"
                    testClasstList.add(key)
                    PR_NEEDED=true
                }
            }
        }
        if (PR_NEEDED){
            echo "create comment as PR_NEEDED is ${PR_NEEDED}"
            update_jckmk_file(testClasstList)
            COMMENT=" Splitter.sh resulted in new test groups.\\r\\nWe need to create PR to update jck.mk file for below test group\\r\\n" + testClasstList.join(", ")
        } else {
            COMMENT =" No need to creat PR to update jck.mk file."
        }
        createComment(COMMENT)
    }
}

def getJavaSDK(){
        JDK_VERSION_OPTION = env.JDK_VERSION ? "-j ${env.JDK_VERSION}" : ""
        JDK_IMPL_OPTION = env.JDK_IMPL ? "-i ${env.JDK_IMPL}" : ""
        CUSTOMIZED_SDK_URL_OPTION = "-c ${params.CUSTOMIZED_SDK_URL}"
        CLONE_OPENJ9_OPTION = (params.CLONE_OPENJ9) ? "--clone_openj9 ${params.CLONE_OPENJ9}" : ""

        GET_SH_CMD = "./get.sh -s `pwd`/.. -p $PLATFORM -r ${SDK_RESOURCE} ${JDK_VERSION_OPTION} ${JDK_IMPL_OPTION} ${CUSTOMIZED_SDK_URL_OPTION} ${CLONE_OPENJ9_OPTION}"// ${OPENJ9_REPO_OPTION} ${OPENJ9_BRANCH_OPTION} ${OPENJ9_SHA_OPTION} ${TKG_REPO_OPTION} ${TKG_BRANCH_OPTION} "
        dir("${WORKSPACE}/aqa-tests") {
            if (params.CUSTOMIZED_SDK_URL_CREDENTIAL_ID) {
			// USERNAME and PASSWORD reference with a withCredentials block will not be visible within job output
			withCredentials([usernamePassword(credentialsId: "${params.CUSTOMIZED_SDK_URL_CREDENTIAL_ID}", usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
				sh "$GET_SH_CMD"
			}
		} else {
			sh "$GET_SH_CMD"
		}
            // sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true) {
            //     sh "$GET_SH_CMD"
	        // }
        }
}

def target_Folder_check(){
            env.TEST_JDK_HOME = "$WORKSPACE/openjdkbinary/j2sdk-image"
            echo "TEST_JDK_HOME == ${env.TEST_JDK_HOME}"
            def logFile = "test.log"
            def COMMENT=""
            dir("${WORKSPACE}/aqa-tests/jck/jck_target_folder_check") {
                sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true){
                    def GIT_BRANCH = params.JCK_GIT_BRANCH ?: ""
                    echo "${GIT_BRANCH}"
                    def SCRIPT = "./jck_target_folder_check.sh ${params.JCK_GIT_REPO} ${WORKSPACE} ${GIT_BRANCH}"
                    def specificLine = "New test folder detected:"

                    def EXITCODE = sh(script: "${SCRIPT} >${logFile}", returnStatus: true)
                    echo "EXITCODE for jck_target_folder_check = ${EXITCODE}"
                    sh "cat ${logFile}"
                        
                    // Use 'grep' to check if any new folders are detected
                    def grepCommand = "grep '${specificLine}' ${logFile} || true"
                    def grepResult = sh(script: grepCommand, returnStatus: true)

                    // grep last few lines after Done! to create comment
                    def fileContents = readFile(file: logFile).trim()
                    def delimiter = 'Done!'
                    def parts = fileContents.split(delimiter)
                    def linesAfterDone = parts[1].trim()
                    def lines = linesAfterDone.split('\n')
                    def commentBody = lines.collect { it.trim() }.join('\\r\\n')

                    if (grepResult == 0)  {
                        echo "No new folders detected. No need to update playlist.xml '"
                        COMMENT="No new folders detected. No need to update playlist.xml \\r\\n ``` ${commentBody} "
                    } else {
                        echo "New folders detected. Need to update playlist.xml'"
                        COMMENT="New folders detected. Need to update playlist.xml \\r\\n ``` ${commentBody} "
                        SCRIPT_PR=true
                        udpateFolderCheck()
                    }
                }
            }
            createComment(COMMENT)
}


def udpateFolderCheck(){
    dir("${WORKSPACE}/aqa-tests/jck") {
        sshagent(credentials:["${params.EXTN_GIT_CREDS}"], ignoreMissing: true){
            sh """
                git branch
                git remote add origin1 git@github.com:KapilPowar/aqa-tests.git
	            git remote add upstream1 git@github.com:KapilPowar/aqa-tests.git
                git checkout -b test
                git branch
            """
            SCRIPT_PR=true
            def sourceFilePath = createFile()
            def modifiedFiles = []
            //def sourceFilePath = logFile
            def sourceFileContent = readFile(file: sourceFilePath)
            def pattern = /(?s)(New test folder detected:(.*?)<\/test>)/
            def matches = (sourceFileContent =~ pattern)
            def compilerMap = [
                '/lang': 'compiler.lang/playlist.xml',
                '/api': 'compiler.api/playlist.xml'
                // Add other mappings as needed
            ]
            def runtimeMap = [
                '/lang': 'runtime.lang/playlist.xml',
                '/api': 'runtime.api/playlist.xml',
                '/vm': 'runtime.vm/playlist.xml'
                // Add other mappings as needed
            ]
            matches.each { match ->
                def fullMatch = match[0]
                def pathMatch = fullMatch =~ /New test folder detected:\s*(\S+)/
                def fullPath = pathMatch[0][1].trim()
                // Extract just the directory path (e.g., /lang or /api)
                def path = fullPath =~ /\/(\w+)\//
                if (path.size() > 0) {
                    path = "/${path[0][1]}"
                }
                // Check if a target file path is defined for the path
                def targetFilePath=""
                if (fullMatch.contains("COMPILER")) {
                    targetFilePath = compilerMap[path]
                } else{
                    targetFilePath = runtimeMap[path]
                }

                if (targetFilePath) {
                    // Read the current target file content
                    def targetFileContent = readFile(file: targetFilePath)
                    // Extract the content from <test> to </test> in the match block
                    def matcher = fullMatch =~ /(?s)(<test>(.*?)<\/test>)/
                    //def testContent=""
                    if (matcher.find()) {
                        //testContent = matcher.group(0)
                        // Append the test block (excluding "New test folder detected" line) to the target file content
                        def updatedTargetContent = targetFileContent.replace('</playlist>', "\t${matcher.group(0)}\n</playlist>")
                        // Write the updated content back to the target XML file
                        //echo " testContent ---  ${testContent}"
                        //echo " updatedTargetContent ---  $updatedTargetContent"
                        writeFile(file: targetFilePath, text: updatedTargetContent)
                        echo "Updated target XML file: $targetFilePath"
                        modifiedFiles.add(targetFilePath)
                        // sh """
                        // git diff targetFilePath
                        // """
                    } else {
                        echo "No match found."
                    }
                } else {
                    echo "No target file mapping found for path: $path"
                }
            }
            def filesToStage = modifiedFiles.join(' ')
            def gitAddCommand = "git add ${filesToStage}"
            sh """
                git branch
                git config --global user.email "KapilPowar@in.ibm.com"
		        git config --global user.name "KapilPowar"
            """
            sh(script: gitAddCommand)
            sh """
                git commit -m "update folder check"
                git push origin1 test
            """
        }
    }
}
def update_jckmk_file(testClasstList){

    //def sourceFilePath = "test.log"
    //dir("${WORKSPACE}/aqa-tests/jck") {
     sshagent(credentials:["${params.EXTN_GIT_CREDS}"], ignoreMissing: true){
    if (!SCRIPT_PR){  
     SCRIPT_PR=true  
     sh """
                git branch
                git remote add origin1 git@github.com:KapilPowar/aqa-tests.git
	            git remote add upstream1 git@github.com:KapilPowar/aqa-tests.git
                git checkout -b test
                git branch
            """
    }
    def targetFilePath = "${WORKSPACE}/aqa-tests/jck/jck.mk"
    JDK_VERSION = params.JDK_VERSION
    def blockCondition = "ifeq (${JDK_VERSION}, \$(JDK_VERSION))"

    sshagent(credentials:["${params.EXTN_GIT_CREDS}"], ignoreMissing: true){
    testClasstList.each{ test ->
        def sourceFilePath = "${test}.log"
        echo "file --- ${sourceFilePath}"
        // Read all lines from the source file containing "="
        def sourceLines = readFile(file: sourceFilePath).readLines().findAll { it.contains('=') }

        // Read the target file into a list
        def targetLines = readFile(file: targetFilePath).readLines()

        // Iterate through the source lines
        sourceLines.each { sourceLine ->
            // Split the source line by "="
            def sourceParts = sourceLine.split('=')
            def sourceKey = sourceParts[0]
            // Initialize a flag to determine if we have replaced a line
            def lineReplaced = false
            def insideBlock = false
            def keywords = ["COMPILER", "VERIFIER", "RUNTIME"]
            // Iterate through the target lines
            def updatedTargetLines = targetLines.collect { line ->
                def lineContainsKeywords =keywords.any { keyword -> line.contains(keyword) }
                if (line.contains(blockCondition)) {
                    insideBlock = true
                    line
                }else if (!(line.isEmpty() ||line.trim().isEmpty()) && !lineContainsKeywords) {
                    insideBlock = false
                    line
                }else if (insideBlock && !lineReplaced && line.contains(sourceKey)) {
                        //println "source key -- ${sourceKey}"
                        lineReplaced = true
                        //println sourceLine
                        "   ${sourceLine}"
                }else {
                        line
                }
            }
            // Update the target lines for the next source line
            targetLines = updatedTargetLines
        }
        // Write the updated target lines back to the target file
        writeFile(file: targetFilePath, text: targetLines.join('\n'))
    }
    echo "jck.mk --- ${targetFilePath}"
    //sh "cat ${targetFilePath}"
    // sh """
    //     git branch
    //     git status
    // """
    def gitAddCommand = "git add ${targetFilePath}"
    sh(script: gitAddCommand)

    sh """
        git commit -m "update jck.mk"
        git push origin1 test
    """
    }
    }
}

def create_PR_for_scripts() {
    dir("${WORKSPACE}/aqa-tests") {
    sshagent(credentials:["${params.EXTN_GIT_CREDS}"], ignoreMissing: true){
        // sh """
        // git branch
        // git status
        // """
    title="Update jck.mk and playlist.xml file"
	body="This is a new pull request"
	echo " Creating PR for jck.mk and playlist.xml file"
	PERSONAL_GIT_TOKEN="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"
    url="https://api.github.com/repos/KapilPowar/aqa-tests/pulls"
     //-d "{"title":"$title","body":"$body","head":\"KapilPowar:test\",\"base\":\"jcksync-copy"}" \
    def curlCommand = """
                        curl -X POST "${url}" \\
                            -H "Authorization: token ${PERSONAL_GIT_TOKEN}" \\
                            -H "Content-Type: application/json" \\
                            -d '{
                                "title": "${title}",
                                "body": "${body}",
                                "head": "KapilPowar:test",
                                "base": "jcksync-copy"
                            }'
                    """
    def response = sh(script: curlCommand, returnStatus: true,returnStdout: true)
    // def response = sh(script: """
    //     curl -X POST \
    //     -H "Authorization: token $PERSONAL_GIT_TOKEN" \
    //         -H "Content-Type: application/json" \
    //         -d '{"title":"$title","body":"$body","head":"KapilPowar:test","base":"jcksync-copy"}' \
    //         "$url"
    //     """, returnStatus: true, returnStdout: true)
        if (response == 0) {
            echo "PR created"
        } else {
            error "Failed to create Pull Request"
        }
    }
}
}

def createComment(TestComment) {
            withCredentials([
                string(credentialsId: "${params.GIT_CREDENTIALS}",variable: 'GIT_CREDENTIALS')
            ]) {
                def JCK_GIT_REPO = params.JCK_GIT_REPO
                def GIT_USER = JCK_GIT_REPO.split(':')[1].split('/')[0]
                
                JDK_VERSION = params.JDK_VERSION
                def comment_url="https://github.ibm.com/api/v3/repos/${GIT_USER}/JCK${JDK_VERSION}-unzipped/issues/${PR}/comments"
                def COMMENT = "${TestComment}"
                def curlCommand = """
                    curl -X POST -H "Authorization: token ${GIT_CREDENTIALS}" -d '{ 
                    "body":"$COMMENT" 
                    }' "$comment_url"
                """
                //Execute the curl command using sh
                def exitCode = sh(script: curlCommand, returnStatus: true, returnStdout: true)
                if (exitCode == 0) {    
                    echo "Comment added successfully."
                } else {
                    error "Failed to add a comment."
                }
            }
}

def extractNumber(output) {
    def lines = output.readLines()
    for (line in lines) {
        if (line =~ /PR_Number=(\d+)/) {
            return line.replaceAll(/.*PR_Number=(\d+).*/, '$1')
        }
    }
    return 0
}

def createFile(){
    def logFile = "test1.log"
    def fileContent = """
    Cleaning up generated target list..
Done!
--------------------------------------------------------
     Cross-checking test folders under: compiler       
--------------------------------------------------------
New test folder detected: ./lang/ANNOT1 | Please add target: jck-compiler-lang-ANNOT1
	<test>
		<testCaseName>jck-compiler-lang-ANNOT1</testCaseName>
		<variations>
			<variation>NoOptions</variation>
		</variations>
		<command>\$(GEN_JTB_GENERIC) tests=lang/ANNOT1 testsuite=COMPILER; \\
		\$(EXEC_COMPILER_TEST); \\
		\$(TEST_STATUS); \\
		\$(GEN_SUMMARY_GENERIC) tests=lang/ANNOT1 testsuite=COMPILER
		</command>
		<levels>
			<level>extended</level>
		</levels>
		<groups>
			<group>jck</group>
		</groups>
	</test>
New test folder detected: ./lang/STMT1 | Please add target: jck-compiler-lang-STMT1
	<test>
		<testCaseName>jck-compiler-lang-STMT1</testCaseName>
		<variations>
			<variation>NoOptions</variation>
		</variations>
		<command>\$(GEN_JTB_GENERIC) tests=lang/STMT1 testsuite=COMPILER; \\
		\$(EXEC_COMPILER_TEST); \\
		\$(TEST_STATUS); \\
		\$(GEN_SUMMARY_GENERIC) tests=lang/STMT1 testsuite=COMPILER
		</command>
		<levels>
			<level>extended</level>
		</levels>
		<groups>
			<group>jck</group>
		</groups>
	</test>
Total new folders detected : 2
--------------------------------------------------------
     Cross-checking test folders under: runtime       
--------------------------------------------------------
New test folder detected: ./lang/ARR1 | Please add target: jck-runtime-lang-ARR1
	<test>
		<testCaseName>jck-runtime-lang-ARR1</testCaseName>
		<variations>
			<variation>NoOptions</variation>
		</variations>
		<command>\$(GEN_JTB_GENERIC) tests=lang/ARR1 testsuite=RUNTIME; \\
		\$(EXEC_RUNTIME_TEST); \\
		\$(TEST_STATUS); \\
		\$(GEN_SUMMARY_GENERIC) tests=lang/ARR1 testsuite=RUNTIME
		</command>
		<levels>
			<level>extended</level>
		</levels>
		<groups>
			<group>jck</group>
		</groups>
	</test>
New test folder detected: ./api/test | Please add target: jck-runtime-api-test
	<test>
		<testCaseName>jck-runtime-api-test</testCaseName>
		<variations>
			<variation>NoOptions</variation>
		</variations>
		<command>\$(GEN_JTB_GENERIC) tests=api/test testsuite=RUNTIME; \\
		\$(EXEC_RUNTIME_TEST); \\
		\$(TEST_STATUS); \\
		\$(GEN_SUMMARY_GENERIC) tests=api/test testsuite=RUNTIME
		</command>
		<levels>
			<level>extended</level>
		</levels>
		<groups>
			<group>jck</group>
		</groups>
	</test>
Total new folders detected : 2
Wed Sep 20 18:43:17 IST 2023
Total process took ~ 1 seconds.
"""
writeFile(file: logFile, text: fileContent)
return logFile
}
