#!groovy

// def PLATFORM_MAP = [
//     'arm_linux' : [
//         'SPEC' : 'linux_arm',
//         'LABEL' : 'ci.role.test&&sw.os.linux&&hw.arch.aarch32',
//     ],
//     'aarch64_mac' : [
//         'SPEC' : 'osx_aarch64',
//         'LABEL' : 'ci.role.test&&hw.arch.aarch64&&(sw.os.osx||sw.os.mac)',
//     ],
//     'aarch64_linux' : [
//         'SPEC' : 'linux_aarch64',
//         'LABEL' : 'ci.role.test&&sw.os.linux&&hw.arch.aarch64',
//     ],
//     'aarch64_windows' : [
//         'SPEC' : 'windows_aarch64',
//         'LABEL' : 'ci.role.test&&sw.os.windows&&hw.arch.aarch64',
//     ],
//     'aarch64_alpine-linux' : [
//         'SPEC' : 'alpine-linux_aarch64',
//         'LABEL' : 'ci.role.test&&hw.arch.aarch64&&sw.os.alpine-linux',
//     ],
//     'ppc32_aix' : [
//         'SPEC' : 'aix_ppc',
//         'LABEL' : 'ci.role.test&&hw.arch.ppc64&&sw.os.aix',
//     ],
//     'ppc32_linux' : [
//         'SPEC' : 'linux_ppc',
//         'LABEL' : 'ci.role.test&&hw.arch.ppc64&&sw.os.linux',
//     ],
//     'ppc64_aix' : [
//         'SPEC' : 'aix_ppc-64',
//         'LABEL' : 'ci.role.test&&hw.arch.ppc64&&sw.os.aix',
//     ],
//     'ppc64_linux' : [
//         'SPEC' : 'linux_ppc-64',
//         'LABEL' : 'ci.role.test&&hw.arch.ppc64&&sw.os.linux',
//     ],
//     'ppc64le_linux' : [
//         'SPEC' : 'linux_ppc-64_le',
//         'LABEL' : 'ci.role.test&&hw.arch.ppc64le&&sw.os.linux',
//         'DynamicAgents' : ['fyre']
//     ],
//     'riscv64_linux' : [
//         'SPEC' : 'linux_riscv64',
//         'LABEL' : 'ci.role.test&&sw.os.linux&&hw.arch.riscv',
//         'DockerAgents' : ['default']
//     ],
//     'riscv64_linux_xl' : [
//         'SPEC' : 'linux_riscv64',
//         'LABEL' : 'ci.role.test&&sw.os.linux&&hw.arch.riscv&&hw.bits.64',
//     ],
//     's390_linux' : [
//         'SPEC' : 'linux_390',
//         'LABEL' : 'ci.role.test&&hw.arch.s390x&&sw.os.linux&&hw.bits.32',
//     ],
//     's390x_linux_zt' : [
//         'SPEC' : 'linux_390-64_zt',
//         'LABEL' : 'ci.role.test&&hw.arch.znext&&sw.os.linux',
//     ],
//     's390x_linux' : [
//         'SPEC' : 'linux_390-64',
//         'LABEL' : 'ci.role.test&&hw.arch.s390x&&sw.os.linux',
//     ],
//     's390x_zos' : [
//         'SPEC' : 'zos_390-64',
//         'LABEL' : 'ci.role.test&&hw.arch.s390x&&sw.os.zos',
//     ],
//     's390x_zos_xl' : [
//         'SPEC' : 'zos_390-64',
//         'LABEL' : 'ci.role.test&&hw.arch.s390x&&sw.os.zos',
//     ],
//     's390x_zos_zt' : [
//         'SPEC' : 'zos_390-64_zt',
//         'LABEL' : 'ci.role.test&&hw.arch.znext&&sw.os.zos',
//     ],
//     's390_zos_zt' : [
//         'SPEC' : 'zos_390_zt',
//         'LABEL' : 'ci.role.test&&hw.arch.znext&&sw.os.zos',
//     ],
//     's390_zos' : [
//         'SPEC' : 'zos_390',
//         'LABEL' : 'ci.role.test&&hw.arch.s390x&&sw.os.zos',
//     ],
//     'sparcv9_solaris' : [
//         'SPEC' : 'sunos_sparcv9-64',
//         'LABEL' : 'ci.role.test&&hw.arch.sparcv9&&sw.os.sunos',
//     ],
//     'x86-64_solaris' : [
//         'SPEC' : 'sunos_x86-64',
//         'LABEL' : 'ci.role.test&&hw.arch.x86&&sw.os.sunos',
//     ],
//     'x86-64_alpine-linux' : [
//         'SPEC' : 'alpine-linux_x86-64',
//         'LABEL' : 'ci.role.test&&hw.arch.x86&&sw.os.alpine-linux',
//     ],
//     'x86-32_linux' : [
//         'SPEC' : 'linux_x86',
//         'LABEL' : 'ci.role.test&&hw.arch.x86&&sw.os.linux',
//     ],
//     'x86-32_windows' : [
//         'SPEC' : 'win_x86',
//         'LABEL' : 'ci.role.test&&hw.arch.x86&&sw.os.windows',
//     ],
//     'x86-64_linux' : [
//         'SPEC' : 'linux_x86-64',
//         'LABEL' : 'ci.role.test&&hw.arch.x86&&sw.os.linux',
//         'DynamicAgents' : ['azure', 'fyre']
//     ],
//     'x86-64_mac' : [
//         'SPEC' : 'osx_x86-64',
//         'LABEL' : 'ci.role.test&&hw.arch.x86&&(sw.os.osx||sw.os.mac)',
//     ],
//     'x86-64_windows' : [
//         'SPEC' : 'win_x86-64',
//         'LABEL' : 'ci.role.test&&hw.arch.x86&&sw.os.windows',
//     ],
// ]

def PR = 0
timestamps{
    stage('Setup') {
            //if (PLATFORM_MAP.containsKey(params.PLATFORM)) {
                   // SPEC = PLATFORM_MAP[params.PLATFORM]["SPEC"]
                   SPEC = "linux_x86-64"
                    if (params.LABEL) {
                        LABEL = params.LABEL
                    } else {
                        //LABEL = PLATFORM_MAP[params.PLATFORM]["LABEL"]
                        LABEL = "ci.role.test&&hw.arch.x86&&sw.os.linux"
                    }
            node(LABEL) {
                echo "clone the SCM GIT repo"
                 println "SPEC: ${SPEC}"
                println "LABEL: ${LABEL}"
                try {
                    //def retry_count = 0
                    //def sleep_time = 180
                    def gitConfig = scm.getUserRemoteConfigs().get(0)
                    // Adopt windows machines require env here https://github.com/adoptium/aqa-tests/issues/1803
                    ref_cache = "${env.HOME}/openjdk_cache"
                    //retry(5) {
                        // if (retry_count > 0) {
                        //     sleep(sleep_time)
                        // }
                        //retry_count++
                        timeout(time: 1, unit: 'HOURS') {
                            forceCleanWS()
                        }
                        checkout scm: [$class: 'GitSCM',
                        branches: [[name: "${scm.branches[0].name}"]],
                        extensions: [
                            [$class: 'CleanBeforeCheckout'],
                            [$class: 'CloneOption', reference: ref_cache],
                            [$class: 'RelativeTargetDirectory', relativeTargetDir: 'aqa-tests']],
                        userRemoteConfigs: [[url: "${gitConfig.getUrl()}"]]
                        ]
                       // }
                     syncJckMaterial()

                    } catch (Exception e) {
                        println("Exception: " + e.toString())
                        // build result may not be updated correctly at the moment (see https://issues.jenkins.io/browse/JENKINS-56402)
                        // if there is an exception, set currentBuild.result to ABORTED/FAILURE
                        if (e.toString().contains("FlowInterruptedException")) {
                            currentBuild.result = 'ABORTED'
                        } else {
                            currentBuild.result = 'FAILURE'
                        }
                    } finally {
                            timeout(time: 5, unit: 'MINUTES') {
                                if (currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                                    echo "Build was successful."
                                    currentBuild.result = "SUCCESS"
                                } else if (currentBuild.resultIsWorseOrEqualTo('FAILURE')) {
                                    echo "Build failed."
                                    currentBuild.result = "FAILED"
                                } else {
                                    echo "Build status is unknown or unstable."
                                    currentBuild.result = "UNSTABLE"
                                }
                                def build_status=("${env.JOB_NAME} #${env.BUILD_NUMBER} result is $currentBuild.result .")
                                println "$build_status"
                                //createComment(build_status)
                            }
                    }
                }
        //     } else {
        //         assert false : "Cannot find key PLATFORM: ${params.PLATFORM} in PLATFORM_MAP: ${PLATFORM_MAP}."
        // }
    }
}

def getGitRepoBranch(defaultOwnerBranch, repo) {
	String[] actualRepoBranch = defaultOwnerBranch.split(":")
	String owner = actualRepoBranch[0].trim()
	String repoURL = "https://github.com/${owner}/${repo}.git"
	actualRepoBranch[0] = repoURL
	actualRepoBranch[1] = actualRepoBranch[1].trim()
	return actualRepoBranch
}

def forceCleanWS() {
    try {
        cleanWs disableDeferredWipeout: true, deleteDirs: true
    } catch (Exception e) {
        echo 'Exception: ' + e.toString()
        //cleanWs has issue to delete workspace that contains non-ASCII filename in TKG output https://issues.jenkins.io/browse/JENKINS-33478
        //cannot delete workspace directly. Otherwise, Jenkins job will abort due to missing workspace
        sh "rm -rf ${env.WORKSPACE}/aqa-tests/TKG"
        // call cleanWs() again
        cleanWs disableDeferredWipeout: true, deleteDirs: true
    }
}

def syncJckMaterial(){
        echo "Starting script to sync JCK materials ....."
        def JCK_VERSION = params.JDK_VERSION ? "-j ${params.JDK_VERSION}": ""
        def GIT_DEV_BRANCH = params.JCK_GIT_BRANCH ? "-gb ${params.JCK_GIT_BRANCH}": ""
        def JAVA_HOME = params.JAVA_HOME ? "-java ${params.JAVA_HOME}": ""
        def ARTIFACTORY_URL = params.ARTIFACTORY_URL ? "-au ${params.ARTIFACTORY_URL}": ""
        def JCK_GIT_REPO = params.JCK_GIT_REPO ? "-repo ${params.JCK_GIT_REPO}": ""
        def EXITCODE = 1
        //def jenkinsfile = load "${WORKSPACE}/aqa-tests/buildenv/jenkins/JenkinsfileBase"
        
        stage('Build') {
                script {
                    
                        getJavaSDK()
                        
                        withCredentials([
                            usernamePassword(credentialsId: "${params.ARTIFACTORY_CREDENTIALS}",
						usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_CREDENTIALS'),
                            string(credentialsId: "${params.GIT_CREDENTIALS}",variable: 'GIT_CREDENTIALS')
                        ]) {
                                def currentDirectory = sh(script: 'pwd', returnStdout: true).trim()
                                dir("${currentDirectory}/aqa-tests/jck/jck-semiauto-updater") {
                                    sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true){
                                        def SCRIPT = "./jckupdater.sh ${JCK_VERSION} -at ${ARTIFACTORY_CREDENTIALS} ${JCK_GIT_REPO}  -gt ${GIT_CREDENTIALS}  ${ARTIFACTORY_URL}  ${GIT_DEV_BRANCH}  ${JAVA_HOME} "
                                        echo "${SCRIPT}"
                                        def scriptOutput = sh(script: "${SCRIPT}",  returnStdout: true)
                                        EXITCODE = sh(script: "echo \$?", returnStatus: true)
                                        echo "EXITCODE= ${EXITCODE}"
                                        def output = scriptOutput.trim()
                                        echo "Shell script output:"
                                        echo output
                                        //echo "PR number TEST_ENV = ${env.TEST_ENV}"
                                        if (EXITCODE == 2) {
                                            echo "script returned exit code 2, No new update available. Marking the job as SUCCESS. "
                                        } else if (EXITCODE == 0) {
                                            echo "script returned exit code 0, new update is available and PR is created, proceeding to Stage 2."
                                            PR = extractNumber(output)
                                            echo "Value of PR NUMBER: $PR"
                                        } else {
                                            error("script failed with exit code ${EXITCODE}")
                                        }
                                    }
                                   
                                }
                            }
                    }
                }

        stage( 'Splitter'){
            script{
                    //createComment()
                    //def job_id = BUILD_URL
                    //def comment="Test Jenkins job link $BUILD_URL"
                    
                    // createComment(comment)
                    if (EXITCODE==0){
                    target_JCK_Folder()
                    getSplitter()
                    }
                }
            }

       stage('SanityTest') {
               script{
                   if (EXITCODE==0){
                        //def test_job="Grinder_JCK"
                        // jenkinsfile.addJobDescription()
                        // jenkinsfile.addGrinderLink()
                        //jenkinsfile.testExecution()
                        // jenkinsfile.terminateTestProcesses()
                        // build job: test_job, parameters: childParams
                  }
              }
      }
    }

def getSplitter(){
    dir("${WORKSPACE}/aqa-tests/jck/splitter") {
        def JDK_VERSION= params.JDK_VERSION
        if (JDK_VERSION == "8") {
            JDK_VERSION = "8d"
        } else if (JDK_VERSION == "11"){
             JDK_VERSION = "11"
        } 
        def TESTS_MAP = [
            'ANNOT' : [
                'TESTS' : 'ANNOT',
                'GROUP' : 5,
            ],
            'CLSS' : [
                'TESTS' : 'CLSS',
                'GROUP' : 10,
            ],
            // 'CONV' : [
            //     'TESTS' : 'CONV',
            //     'GROUP' : '5',
            // ],
            // 'DASG' : [
            //     'TESTS' : 'DASG',
            //     'GROUP' : '5',
            // ],
            // 'EXPR' : [
            //     'TESTS' : 'EXPR',
            //     'GROUP' : '11',
            // ],
            // 'INTF' : [
            //     'TESTS' : 'INTF',
            //     'GROUP' : '5',
            // ],
            // 'LMBD' : [
            //     'TESTS' : 'LMBD',
            //     'GROUP' : '5',
            // ],
            // 'NAME' : [
            //     'TESTS' : 'NAME',
            //     'GROUP' : '5',
            // ],
            // 'TYPE' : [
            //     'TESTS' : 'TYPE',
            //     'GROUP' : '5',
            // ],
            // 'STMT' : [
            //     'TESTS' : 'STMT',
            //     'GROUP' : '5',
            // ],
        ]
        def TARGET_TO_SPLIT = "${WORKSPACE}/test/JCK-compiler-${JDK_VERSION}/tests/lang"
        def SCRIPT=""
        def PR_NEEDED = false
        def tesClasstList = []
        TESTS_MAP.each { key, value ->
             if (value.containsKey('TESTS') && value.containsKey('GROUP')) {
                def testsValue = value['TESTS']
                def groupValue = value['GROUP']
                echo "Calling splitter.sh for TESTS: $testsValue and GROUP:$groupValue"
                // Call the test.sh script here, passing testsValue as an argument
                TARGET="${TARGET_TO_SPLIT}/${testsValue}"
                SCRIPT = "./splitter.sh ${TARGET}"
                def logFileName = "${testsValue}.log"
                EXITCODE = sh(script: "${SCRIPT} ${groupValue} > ${logFileName}", returnStatus: true)
                
                echo "EXITCODE in splitter =${EXITCODE}"
                //sh "cat ${logFileName}"
                if (testsValue == "CLSS"){
                    testsValue="CLASS"
                }
                def mkFileName = "${WORKSPACE}/aqa-tests/jck/jck.mk"
                def lastLine = null
                // Read the last line starting with COMPILER_LANG_ANNOT_TESTS_GROUP from logFileName.log
                    def logFileContents = readFile(file: logFileName).trim().split('\n')
                    for (int i = logFileContents.size() - 1; i >= 0; i--) {
                        def line = logFileContents[i]
                        if (line.startsWith("COMPILER_LANG_${testsValue}_TESTS_GROUP")) {
                            lastLine = line
                            break
                        }
                    }
                // Check if the last line is present in test.mk
                    def mkFileContents = readFile(file: mkFileName).trim()
                    echo "Last test group in ${logFileName}: ${lastLine}"
                    if (lastLine && mkFileContents.contains(lastLine)) {
                        echo "The line is present in $mkFileName"
                        echo "No need to create PR for --- $testsValue"
                    } else {
                        echo "The line is not present in $mkFileName"
                        echo "We need to update $mkFileName and create PR for --- $testsValue"
                        tesClasstList.add(testsValue)
                        PR_NEEDED=true
                    }
            }
        }
        if (PR_NEEDED){
            echo "create comment as PR_NEEDED is ${PR_NEEDED}"
            def comment=" Splitter.sh resulted in new test groups.\\r\\nWe need to create PR to update jck.mk file for below test group\\r\\n" + tesClasstList.join(", ")
            createComment(comment)
        } else {
            def comment =" No need to creat PR to update jck.mk file."
            createComment(comment)
        }
    }
}

def getJavaSDK(){
        JDK_VERSION_OPTION = env.JDK_VERSION ? "-j ${env.JDK_VERSION}" : ""
                        JDK_IMPL_OPTION = env.JDK_IMPL ? "-i ${env.JDK_IMPL}" : ""
                        CUSTOMIZED_SDK_URL_OPTION = "-c ${params.CUSTOMIZED_SDK_URL}"
                        CLONE_OPENJ9_OPTION = (params.CLONE_OPENJ9) ? "--clone_openj9 ${params.CLONE_OPENJ9}" : ""
                        OPENJ9_SHA_OPTION = (params.OPENJ9_SHA) ? "--openj9_sha ${params.OPENJ9_SHA}" : ""
                        String[] tkg = getGitRepoBranch("adoptium:master", "TKG")
                        TKG_REPO = tkg[0]
                        TKG_BRANCH = tkg[1]
                        if(!params.USE_TESTENV_PROPERTIES){
                            OPENJ9_REPO_OPTION = "--openj9_repo ${OPENJ9_REPO}"
                            OPENJ9_BRANCH_OPTION = "--openj9_branch ${OPENJ9_BRANCH}"
                            TKG_REPO_OPTION = "--tkg_repo ${TKG_REPO}"
                            TKG_BRANCH_OPTION = "--tkg_branch ${TKG_BRANCH}"
                        }
                        GET_SH_CMD = "./get.sh -s `pwd`/.. -p $PLATFORM -r ${SDK_RESOURCE} ${JDK_VERSION_OPTION} ${JDK_IMPL_OPTION} ${CUSTOMIZED_SDK_URL_OPTION} "//${CLONE_OPENJ9_OPTION} ${OPENJ9_REPO_OPTION} ${OPENJ9_BRANCH_OPTION} ${OPENJ9_SHA_OPTION} ${TKG_REPO_OPTION} ${TKG_BRANCH_OPTION} "
                        dir("${WORKSPACE}/aqa-tests") {
                        sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true) {
                           sh "$GET_SH_CMD"
	                        }
                        }
}

def target_JCK_Folder(){
                env.TEST_JDK_HOME = "$WORKSPACE/openjdkbinary/j2sdk-image"
                echo "TEST_JDK_HOME == ${env.TEST_JDK_HOME}"
                def comment=""
                
                dir("${WORKSPACE}/aqa-tests/jck/jck_target_folder_check") {
                    sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true){
                        def JCK_GIT_REPO = params.JCK_GIT_REPO ?: ""
                        def GIT_BRANCH = params.JCK_GIT_BRANCH ?: ""
                        echo "${GIT_BRANCH}"
                        def SCRIPT = "./jck_target_folder_check.sh ${params.JCK_GIT_REPO} ${WORKSPACE} ${GIT_BRANCH}"
                        def logFile = "test.log"
                        def specificLine = "Total new folders detected : 0"

                        EXITCODE = sh(script: "${SCRIPT} >${logFile}", returnStatus: true)
                        echo "${EXITCODE}"
                        sh "cat ${logFile}"
                        
                        // Use 'grep' to search for the specific line in the log file
                        def grepCommand = "grep '${specificLine}' ${logFile}"
                        def grepResult = sh(script: grepCommand, returnStatus: true)
                        // grep last few lines after Done! to create comment
                        def fileContents = readFile(file: logFile).trim()
                        def delimiter = 'Done!'
                        def parts = fileContents.split(delimiter)
                        def linesAfterDone = parts[1].trim()
                        def lines = linesAfterDone.split('\n')
                        def newVariable = lines.collect { it.trim() }.join('\\r\\n')
                                
                        if (grepResult == 0) {
                        echo "Specific line found in the log file: '${specificLine}'"
                        comment="No new folders detected. No need to update playlist.xml \\r\\n ``` ${newVariable} ```"
                        } else {
                        echo "Specific line not found in the log file"
                        comment="New folders detected. Need to update playlist.xml \\r\\n ``` ${newVariable} ``` "
                        }
                    }
                }

            createComment(comment)
}

def createComment(TestComment) {
            withCredentials([
                string(credentialsId: "${params.GIT_CREDENTIALS}",variable: 'GIT_CREDENTIALS')
            ]) {
                def JCK_GIT_REPO = params.JCK_GIT_REPO
                def GIT_USER = JCK_GIT_REPO.split(':')[1].split('/')[0]
                echo "GIT_USER: $GIT_USER"
                
                JCK_VERSION = params.JDK_VERSION ?: ""
                //def pr_number = getPRNumber()
                println "PR number created is $PR" 
                def comment_url="https://github.ibm.com/api/v3/repos/${GIT_USER}/JCK${JCK_VERSION}-unzipped/issues/${PR}/comments"
                def comment = "${TestComment}"
                def curlCommand = """
                    curl -X POST -H "Authorization: token ${GIT_CREDENTIALS}" -d '{ 
                    "body":"$comment" 
                    }' "$comment_url"
                """
                //Execute the curl command using sh
                def exitCode = sh(script: curlCommand, returnStatus: true, returnStdout: true)
                if (exitCode == 0) {    
                    echo "Comment added successfully."
                } else {
                    error "Failed to add a comment."
                }
            }
}

// def getPRNumber(){
//                 def pr_number=0
//                 def directory="${WORKSPACE}/aqa-tests/jck/test"
//                 def filePath="${directory}/file.txt"
//                 def version = readFile "${filePath}"
//                 pr_number=version.toInteger()
//                 return pr_number                
// }

def extractNumber(output) {
    def lines = output.readLines()
    for (line in lines) {
        if (line =~ /PR_Number=(\d+)/) {
            return line.replaceAll(/.*PR_Number=(\d+).*/, '$1')
        }
    }
    return null
}
