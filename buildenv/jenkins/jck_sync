#!groovy

timestamps{
    stage('Setup') {
        def SYNC_LABEL = params.SYNC_LABEL ?: "ci.role.test&&hw.arch.x86&&sw.os.linux"
        println "SYNC_LABEL: ${SYNC_LABEL}"
        node(SYNC_LABEL) {
            echo ("clone the SCM GIT repo")
            try {
                def gitConfig = scm.getUserRemoteConfigs().get(0)
                checkout scm: [$class: 'GitSCM',
                branches: [[name: "${scm.branches[0].name}"]],
                extensions: [
                    [$class: 'CleanBeforeCheckout'],
                    [$class: 'CloneOption'],
                    [$class: 'RelativeTargetDirectory', relativeTargetDir: 'aqa-tests']],
                userRemoteConfigs: [[url: "${gitConfig.getUrl()}"]]
                ]
                syncJckMaterial()
            } catch (Exception e) {
                // build result may not be updated correctly at the moment (see https://issues.jenkins.io/browse/JENKINS-56402)
                // if there is an exception, set currentBuild.result to ABORTED/FAILURE
                if (e.toString().contains("The job is completed without further action")){
                    println("JCKUpdater script returned exit code 2, as no new update available. The job is completed without further action.")
                    currentBuild.result = "SUCCESS"
                } else if (e.toString().contains("FlowInterruptedException")) {
                    currentBuild.result = 'ABORTED'
                    println("Exception: " + e.toString())
                } else {
                    currentBuild.result = 'FAILURE'
                    println("Exception: " + e.toString())
                }
            }
        }
    }
}

def syncJckMaterial(){
    echo ("Starting script to sync JCK materials .....")
    def JCK_VERSION = params.JDK_VERSION ? "-j ${params.JDK_VERSION}": ""
    def JCK_GIT_BRANCH = params.JCK_GIT_BRANCH ? "-gb ${params.JCK_GIT_BRANCH}": ""
    def ARTIFACTORY_URL = params.ARTIFACTORY_URL ? "-au ${params.ARTIFACTORY_URL}": ""
    def JCK_GIT_REPO = params.JCK_GIT_REPO ? "-repo ${params.JCK_GIT_REPO}": ""
    def PR_NUMBER = 0
    stage('JCKUpdater') {
        getJavaSDK()

        withCredentials([
            usernamePassword(credentialsId: "${params.ARTIFACTORY_CREDENTIALS}",
			usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_CREDENTIALS'),
            string(credentialsId: "${params.GIT_CREDENTIALS}",variable: 'GIT_CREDENTIALS')
        ]) {
            dir("${WORKSPACE}/aqa-tests/jck/jck-semiauto-updater"){
                sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true){
                    def SCRIPT = "./jckupdater.sh ${JCK_VERSION} -at  \"\$ARTIFACTORY_CREDENTIALS\" ${JCK_GIT_REPO}  -gt \"\$GIT_CREDENTIALS\"  ${ARTIFACTORY_URL}  ${JCK_GIT_BRANCH} "
                    def tempOutputFile = "temp_output.txt"
                    def EXITCODE = sh(script: "${SCRIPT} > ${tempOutputFile}",  returnStatus: true)
                    if (EXITCODE == 2) {
                        error ("JCKUpdater script returned exit code 2, as no new update available. The job is completed without further action.")
                        currentBuild.result = "SUCCESS"
                    } else if (EXITCODE == 0) {
                        echo ("Script returned exit code 0, new update is available and PR is created.")
                        def scriptOutput = readFile(tempOutputFile).trim()
                        echo ("JCKUpdater script output:")
                        echo scriptOutput
                        def matcher = (scriptOutput =~ /PR_NUMBER=\s*(\d+)/)
                        PR_NUMBER = matcher ? matcher[0][1] : null
                        if (PR_NUMBER == null || PR_NUMBER == 0) {
                            error ("PR_NUMBER not found in script output.")
                        } else {
                            echo ("PR created with number : ${PR_NUMBER}")
                        }
                    } else {
                        error ("script failed with exit code ${EXITCODE}")
                    }
                }
            }
        }
    }
    stage('Scripts'){
        targetFolderCheck(PR_NUMBER)
        getSplitter(PR_NUMBER)
    }
    stage('Test') {
        def CHILD_JOB_NAME="Grinder_JCK"
        def BUILD_URL="${JENKINS_URL}job/${CHILD_JOB_NAME}/"
        def CHILD_PARAMS = []
        // loop through all the params and change the parameters if needed
        params.each { param ->
            def value = param.value.toString()
            if (param.key == "JCK_GIT_BRANCH") {
                if (value.trim() == ""){
                    value = "autoBranch" //default branch name given in JCKUpdater.sh script
                }
                CHILD_PARAMS << string(name: param.key, value: value)
            } else {
                if (value == "true" || value == "false") {
                    CHILD_PARAMS << booleanParam(name: param.key, value: value.toBoolean())
                } else {
                    CHILD_PARAMS << string(name: param.key, value: value)
                }
            }
        }
        def BUILD_INFO = build job: CHILD_JOB_NAME, parameters: CHILD_PARAMS
        def COMMENT="Job [#${BUILD_INFO.number}](${BUILD_URL}${BUILD_INFO.number}) completed with status: ${BUILD_INFO.result}"
        createComment(COMMENT,PR_NUMBER)
    }
}

//Download JAVA SDK 
def getJavaSDK(){
    def JDK_VERSION_OPTION = params.JDK_VERSION ? "-j ${params.JDK_VERSION}" : ""
    def CUSTOMIZED_SDK_URL_OPTION = "-c ${params.CUSTOMIZED_SDK_URL}"
    def CLONE_OPENJ9_OPTION = "--clone_openj9 false"
    def PLATFORM_OPTION = "-p x86-64_linux"
    def GET_SH_CMD = "./get.sh -s `pwd`/.. ${PLATFORM_OPTION} ${JDK_VERSION_OPTION} ${CUSTOMIZED_SDK_URL_OPTION} ${CLONE_OPENJ9_OPTION} "
    dir("${WORKSPACE}/aqa-tests") {
        if (params.CUSTOMIZED_SDK_URL_CREDENTIAL_ID) {
			withCredentials([usernamePassword(credentialsId: "${params.CUSTOMIZED_SDK_URL_CREDENTIAL_ID}", usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
			sh "$GET_SH_CMD"
			}
		} else {
			sh "$GET_SH_CMD"
		}
    }
}

def targetFolderCheck(number){
    env.TEST_JDK_HOME = "$WORKSPACE/openjdkbinary/j2sdk-image"
    def COMMENT=""
    def logFile = "test.log"
    dir("${WORKSPACE}/aqa-tests/jck/jck_target_folder_check") {
        sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true){
            def GIT_BRANCH = params.JCK_GIT_BRANCH ?: "autoBranch" //default branch name in jckupdater.sh
            def SCRIPT = "./jck_target_folder_check.sh ${params.JCK_GIT_REPO} ${WORKSPACE} ${GIT_BRANCH}"
            sh(script: "${SCRIPT} >${logFile}", returnStatus: true)
            sh "cat ${logFile}"

            // Use 'grep' to check if any new folders are detected
            def specificLine = "New test folder detected:"
            def grepCommand = "grep '${specificLine}' ${logFile} || true"
            def grepResult = sh(script: grepCommand, returnStatus: true)
            // grep last few lines after Done! to create comment body
            def fileContents = readFile(file: logFile).trim()
            def delimiter = 'Done!'
            def parts = fileContents.split(delimiter)
            def linesAfterDone = parts[1].trim()
            def lines = linesAfterDone.split('\n')
            def commentBody = lines.collect { it.trim() }.join('\\r\\n')

            if (grepResult == 0)  {
                echo "No new folders detected. No need to update playlist.xml '"
                COMMENT="No new folders detected. No need to update playlist.xml \\r\\n ``` ${commentBody} "
            } else {
                echo "New folders detected. Need to update playlist.xml'"
                COMMENT="New folders detected. Need to update playlist.xml \\r\\n ``` ${commentBody} "
            }
        }
    }
    createComment(COMMENT, number)
}

def getSplitter(number){
    dir("${WORKSPACE}/aqa-tests/jck/splitter") {
        def JDK_VERSION= params.JDK_VERSION
        if (JDK_VERSION == "8") {
            JDK_VERSION = "8d"
        } else if (JDK_VERSION == "11"){
            JDK_VERSION = "11a"
        }
        def TESTS_MAP = [
            'ANNOT': ['GROUP' : 5,],
            'CLSS' : ['GROUP' : 10,],
            'CONV' : ['GROUP' : 5,],
            'DASG' : ['GROUP' : 5,],
            'EXPR' : ['GROUP' : 11,],
            'INTF' : ['GROUP' : 5,],
            'LMBD' : ['GROUP' : 5,],
            'NAME' : ['GROUP' : 5,],
            'TYPE' : ['GROUP' : 5,],
            'STMT' : ['GROUP' : 5,],
            'VERIFIER' : ['GROUP' : 4,],
        ]
        def TARGET_TO_SPLIT = "${WORKSPACE}/test/JCK-compiler-${JDK_VERSION}/tests/lang"
        def COMMENT=""
        def PR_NEEDED = false
        def testClasstList = []
        def mkFileName = "${WORKSPACE}/aqa-tests/jck/jck.mk"
        TESTS_MAP.each { key, value ->
            //no verifier group available for JDK8
            if (key == "VERIFIER" && JDK_VERSION == "8d"){
                echo "No need to create PR for Tests Group $key"
            } else if (value.containsKey('GROUP')) {
                def groupValue = value['GROUP']
                TARGET="${TARGET_TO_SPLIT}/${key}"
                if (key == "VERIFIER"){
                    TARGET="${WORKSPACE}/test/JCK-runtime-${JDK_VERSION}/tests/vm/verifier/instructions"
                }
                def SCRIPT = "./splitter.sh ${TARGET} ${groupValue}"
                if (key == "CLSS"){
                    key="CLASS"
                }
                def logFileName = "${key}.log"
                sh(script: "${SCRIPT} > ${logFileName}", returnStatus: true)
                def lastLine = null
                // Read the last line starting with TESTS_GROUP from logFileName.log
                def logFileContents = readFile(file: logFileName).trim().split('\n')
                for (int i = logFileContents.size() - 1; i >= 0; i--) {
                    def line = logFileContents[i]
                    if (line.startsWith("COMPILER_LANG_${key}_TESTS_GROUP") || line.startsWith("VERIFIER_INSTRUCTIONS_TESTS_GROUP") ) {
                        lastLine = line
                        break
                    }
                }
                def mkFileContents = readFile(file: mkFileName).trim()
                if (lastLine && mkFileContents.contains(lastLine)) {
                    echo "No need to create PR for Tests Group $key"
                } else {
                    echo "We need to update $mkFileName and create PR for Tests Group $key"
                    testClasstList.add(key)
                    PR_NEEDED=true
                }
            }
        }
        if (PR_NEEDED){
            echo "create comment as PR_NEEDED is ${PR_NEEDED}"
            COMMENT=" Splitter.sh resulted in new test groups.\\r\\n We need to create PR to update jck.mk file for below test group\\r\\n " + testClasstList.join(", ")
            echo "${testClasstList}"
        } else {
            COMMENT =" No need to create PR to update jck.mk file."
        }
        createComment(COMMENT, number)
    }
}

def createComment(comment,number) {
    withCredentials([
        string(credentialsId: "${params.GIT_CREDENTIALS}",variable: 'GIT_CREDENTIALS')
    ]) {
        def DOMAIN = params.JCK_GIT_REPO.split(/[@:]/)
        def REPO = DOMAIN[2].split('\\.')
        def COMMENT_URL="https://${DOMAIN[1]}/api/v3/repos/${REPO[0]}/issues/${number}/comments"
        def PR_URL="https://${DOMAIN[1]}/${REPO[0]}/pull/${number}"
        def CURL_COMMAND = """
            curl -X POST -H "Authorization: token \"\$GIT_CREDENTIALS\"" \\
            -d '{
            "body":"${comment}"
            }' "$COMMENT_URL"
        """
        def STATUS = sh(script: CURL_COMMAND, returnStatus: true, returnStdout: true)
        if (STATUS == 0) {
            echo ("Comment added successfully to PR ${PR_URL} ")
        } else {
            error ("Failed to add a comment to PR ${PR_URL} ")
        }
    }
}
