#!groovy

timestamps{
    stage('Setup') {
        def SYNC_LABEL = params.SYNC_LABEL ?: "ci.role.test&&hw.arch.x86&&sw.os.linux"
        println "SYNC_LABEL: ${SYNC_LABEL}"
        env.SPEC = "linux_x86"
        println "SPEC: ${env.SPEC}"
        node(SYNC_LABEL) {
            echo "clone the SCM GIT repo"
                try {
                    def gitConfig = scm.getUserRemoteConfigs().get(0)
                    // Adopt windows machines require env here https://github.com/adoptium/aqa-tests/issues/1803
                    // ref_cache = "${env.HOME}/openjdk_cache"
                    timeout(time: 1, unit: 'HOURS') {
                        forceCleanWS()
                    }
                    checkout scm: [$class: 'GitSCM',
                    branches: [[name: "${scm.branches[0].name}"]],
                    extensions: [
                        [$class: 'CleanBeforeCheckout'],
                        [$class: 'CloneOption'],// reference: ref_cache],
                        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'aqa-tests']],
                    userRemoteConfigs: [[url: "${gitConfig.getUrl()}"]]
                    ]
                    syncJckMaterial()

                } catch (Exception e) {
                    //println("Exception: " + e.toString())
                    // build result may not be updated correctly at the moment (see https://issues.jenkins.io/browse/JENKINS-56402)
                    // if there is an exception, set currentBuild.result to ABORTED/FAILURE
                    if (e.toString().contains("Gracefully stop execution of pipeline")){
                        println("JCKUpdater script returned exit code 2, as no new update available. The job is completed without further action")
                        currentBuild.result = "SUCCESS"
                    } else if (e.toString().contains("FlowInterruptedException")) {
                        println("Exception: " + e.toString())
                        currentBuild.result = 'ABORTED'
                    } else {
                        println("Exception: " + e.toString())
                        currentBuild.result = 'FAILURE'
                    }
                } 
                finally {
                    timeout(time: 1, unit: 'HOURS') {
                        forceCleanWS()
                    }
                        // timeout(time: 15, unit: 'MINUTES') {
                        //     if (currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                        //         echo "Build was successful."
                        //         currentBuild.result = "SUCCESS"
                        //     } else if (currentBuild.resultIsWorseOrEqualTo('FAILURE')) {
                        //         echo "Build failed."
                        //         currentBuild.result = "FAILED"
                        //     } else {
                        //         echo "Build status is unknown or unstable."
                        //         currentBuild.result = "UNSTABLE"
                        //     }
                        //     def build_status=("${env.JOB_NAME} #${env.BUILD_NUMBER} result is $currentBuild.result .")
                        //     println "$build_status"
                        //     //createComment(build_status)
                        // }
                }
            }
    }
}

def forceCleanWS() {
    try {
        cleanWs disableDeferredWipeout: true, deleteDirs: true
    } catch (Exception e) {
        echo 'Exception: ' + e.toString()
        //cleanWs has issue to delete workspace that contains non-ASCII filename in TKG output https://issues.jenkins.io/browse/JENKINS-33478
        //cannot delete workspace directly. Otherwise, Jenkins job will abort due to missing workspace
        sh "rm -rf ${env.WORKSPACE}/aqa-tests/TKG"
        // call cleanWs() again
        cleanWs disableDeferredWipeout: true, deleteDirs: true
    }
}

def syncJckMaterial(){
    echo "Starting script to sync JCK materials ....."
    echo "Check JDK VERSION"
    //     //def JCK_VERSION = params.JDK_VERSION ? "-j ${params.JDK_VERSION}": ""
    //     def JCK_GIT_BRANCH_OPTION = params.JCK_GIT_BRANCH ? "-gb ${params.JCK_GIT_BRANCH}": ""
    //    // def JAVA_HOME = params.JAVA_HOME ? "-java ${params.JAVA_HOME}": ""
    //     def ARTIFACTORY_URL_OPTION = params.ARTIFACTORY_URL ? "-au ${params.ARTIFACTORY_URL}": ""
    //     def JCK_GIT_REPO_OPTION = params.JCK_GIT_REPO ? "-repo ${params.JCK_GIT_REPO}": ""
    //     //def match = JCK_GIT_REPO_OPTION =~ /(\d+)/
    //     //env.JDK_VERSION = match[0][0]
    //     //echo "Extracted number: $env.JDK_VERSION"
    //     def JCK_VERSION = env.JDK_VERSION ? "-j ${env.JDK_VERSION}": ""
    //     echo "${JCK_VERSION}"
    // def JCK_VERSION_OPTION = params.JDK_VERSION ? "-j ${params.JDK_VERSION}": ""
    // def JCK_GIT_BRANCH_OPTION = params.JCK_GIT_BRANCH ? "-gb ${params.JCK_GIT_BRANCH}": ""
    // def ARTIFACTORY_URL_OPTION = params.ARTIFACTORY_URL ? "-au ${params.ARTIFACTORY_URL}": ""
    // def JCK_GIT_REPO_OPTION = params.JCK_GIT_REPO ? "-repo ${params.JCK_GIT_REPO}": ""
    def JCK_VERSION_OPTION = params.JDK_VERSION ? "-j ${params.JDK_VERSION}": ""
    def JCK_GIT_BRANCH_OPTION = params.JCK_GIT_BRANCH ? "-gb ${params.JCK_GIT_BRANCH}": ""
    def ARTIFACTORY_URL_OPTION = params.ARTIFACTORY_URL ? "-au ${params.ARTIFACTORY_URL}": ""
    def ARTIFACTORY_API_URL_OPTION = params.ARTIFACTORY_API_URL ? "-ap ${params.ARTIFACTORY_API_URL}": ""
    def JCK_GIT_REPO_OPTION = params.JCK_GIT_REPO ? "-repo ${params.JCK_GIT_REPO}": ""
    def GIT_EXCLUDE_API_URL_OPTION = params.GIT_EXCLUDE_API_URL ? "-eu ${params.GIT_EXCLUDE_API_URL}": ""
    //def PR_NUMBER = 0
        def EXITCODE = 1
        def PR_NUMBER=0
        //def PR=0
        stage('JCKUpdater') {
                //script {
                
                getJavaSDK()

                    //udpateFolderCheck()
                    //create_PR_for_scripts()
                    withCredentials([
                        usernamePassword(credentialsId: "${params.ARTIFACTORY_CREDENTIALS}",
					usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_CREDENTIALS'),
                        string(credentialsId: "${params.GIT_CREDENTIALS}",variable: 'GIT_CREDENTIALS')
                    ]) {
                            //def currentDirectory = sh(script: 'pwd', returnStdout: true).trim()
                            dir("${WORKSPACE}/aqa-tests/jck/jck-semiauto-updater"){
                            //dir("${currentDirectory}/aqa-tests/jck/jck-semiauto-updater") {
                                sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true){
                                    def SCRIPT = "./jckupdater.sh ${JCK_VERSION_OPTION} -at  \"\$ARTIFACTORY_CREDENTIALS\" ${JCK_GIT_REPO_OPTION}  -gt \"\$GIT_CREDENTIALS\"  ${ARTIFACTORY_URL_OPTION} ${ARTIFACTORY_API_URL_OPTION} ${JCK_GIT_BRANCH_OPTION} ${GIT_EXCLUDE_API_URL_OPTION} "
                                    //echo "${SCRIPT}"
                                    def tempOutputFile = "temp_output.txt"
                                    //create a temp output file 
                                    //tempOutputFile.text  = "This is the content you want to write to the file."
                                    //def scriptOutput = sh(script: "${SCRIPT} > ${tempOutputFile}",  returnStdout: true)
                                    EXITCODE = sh(script: "${SCRIPT} > ${tempOutputFile}",  returnStatus: true)
                                    //echo "EXITCODE= ${EXITCODE}"
                                    //def scriptOutput = readFile(tempOutputFile).trim()
                                    def scriptOutput = readFile(tempOutputFile).trim()
                                    echo "jckupdater script output:"
                                    echo scriptOutput
                                    if (EXITCODE == 2) {
                                        //echo "script returned exit code 2, No new update available. The job is completed without further action. "
                                        // error "script returned exit code 2, No new update available. The job is completed without further action. "
                                        //currentBuild.result = 'SUCCESS'
                                        error("JCKUpdater script returned exit code 2, as no new update available. Gracefully stop execution of pipeline.") 
                                        currentBuild.result = "SUCCESS"
                                        //exit
                                    } else if (EXITCODE == 0) {
                                        echo "script returned exit code 0, new update is available and PR is created, proceeding to Stage 2."
                                        
                                        def matcher = (scriptOutput =~ /PR_NUMBER=\s*(\d+)/)
                                        PR_NUMBER = matcher ? matcher[0][1] : null
                                        if (PR_NUMBER == null || PR_NUMBER == 0) {
                                            echo "Error: PR_NUMBER not found in script output."
                                            error "PR_NUMBER not found in script output."
                                        } else {
                                            echo "PR created with number : ${PR_NUMBER}"
                                        }
                                    } else {
                                        error("script failed with exit code ${EXITCODE}")
                                    }
                                }
                            }
                        }
                   // }
                //    if (EXITCODE ==2){
                //         return
                //    }
                }

        stage( 'Scripts'){
            def CHILD_JOB_NAME="Folder_Check"
            def buildURL="${JENKINS_URL}job/${CHILD_JOB_NAME}/"
            def childParams = []
            params.each { param ->
                            def value = param.value.toString()
                                if (value == "true" || value == "false") {
                                    childParams << booleanParam(name: param.key, value: value.toBoolean())
                                } else {
                                    childParams << string(name: param.key, value: value)
                                }
                        }
            echo "$childParams"
            def buildInfo = build job: CHILD_JOB_NAME, parameters: childParams
            def comment="${CHILD_JOB_NAME} Job [#${buildInfo.number}](${buildURL}${buildInfo.number}) completed with status: ${buildInfo.result}\\r\\n"
            createComment(comment,PR_NUMBER)
        }

        stage('Test') {
                    def CHILD_JOB_NAME="Grinder_JCK"
                    def buildURL="${JENKINS_URL}job/${CHILD_JOB_NAME}/"
                    def CHILD_PARAMS = []
                    // loop through all the params and change the parameters if needed
                    // if (params.JCK_GIT_BRANCH == null){
                    //     JCK_GIT_BRANCH = "autoBranch" //default branch name given in JCKUpdater.sh script
                    // }
                    params.each { param ->
                            def value = param.value.toString()
                            if (param.key == "JCK_GIT_BRANCH") {
                                //echo "value -- $value"
                                if (value.trim() == ""){
                                    value = "autoBranch" //default branch name given in JCKUpdater.sh script
                                }
                                //echo "value -- $value"
                                CHILD_PARAMS << string(name: param.key, value: value)
                            } else {
                                if (value == "true" || value == "false") {
                                    CHILD_PARAMS << booleanParam(name: param.key, value: value.toBoolean())
                                } else {
                                    CHILD_PARAMS << string(name: param.key, value: value)
                                }
                            }
                            
                        }
                    //echo "$CHILD_PARAMS"
                    def buildInfo = build job: CHILD_JOB_NAME, parameters: CHILD_PARAMS
                    def COMMENT="${CHILD_JOB_NAME} Job [#${buildInfo.number}](${buildURL}${buildInfo.number}) completed with status: ${buildInfo.result}\\r\\n"
                    createComment(COMMENT,PR_NUMBER)
        //}
    }
}

def targetFolderCheck(number){
            env.TEST_JDK_HOME = "$WORKSPACE/openjdkbinary/j2sdk-image"
            echo "TEST_JDK_HOME == ${env.TEST_JDK_HOME}"
            def logFile = "test.log"
            def COMMENT=""
            def SCRIPT_PR = false
            dir("${WORKSPACE}/aqa-tests/jck/jck_target_folder_check") {
                sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true){
                    def GIT_BRANCH = params.JCK_GIT_BRANCH ?: "autoBranch" //default branch name in jckupdater.sh
                    echo "${GIT_BRANCH}"
                    def SCRIPT = "./jck_target_folder_check.sh ${params.JCK_GIT_REPO} ${WORKSPACE} ${GIT_BRANCH}"
                    def specificLine = "New test folder detected:"

                    def STATUS = sh(script: "${SCRIPT} >${logFile}", returnStatus: true)
                    echo "EXITCODE for jck_target_folder_check = ${STATUS}"
                    sh "cat ${logFile}"
                        
                    // Use 'grep' to check if any new folders are detected
                    def grepCommand = "grep '${specificLine}' ${logFile} || true"
                    def grepResult = sh(script: grepCommand, returnStatus: true)

                    // grep last few lines after Done! to create comment
                    def fileContents = readFile(file: logFile).trim()
                    def delimiter = 'Done!'
                    def parts = fileContents.split(delimiter)
                    def linesAfterDone = parts[1].trim()
                    def lines = linesAfterDone.split('\n')
                    def commentBody = lines.collect { it.trim() }.join('\\r\\n')

                    if (grepResult == 0)  {
                        echo "No new folders detected. No need to update playlist.xml '"
                        COMMENT="No new folders detected. No need to update playlist.xml \\r\\n ``` ${commentBody} "
                    } else {
                        echo "New folders detected. Need to update playlist.xml'"
                        COMMENT="New folders detected. Need to update playlist.xml \\r\\n ``` ${commentBody} "
                        SCRIPT_PR=udpateFolderCheck()
                    }
                }
            }
            //COMMENT="No new folders detected. No need to update playlist.xml "
            createComment(COMMENT, number)
            udpateFolderCheck() //remove after testing
            //echo "SCRIPT_PR --  $SCRIPT_PR"
            SCRIPT_PR=true
            return SCRIPT_PR
}


def getSplitter(script_pr,number){
    dir("${WORKSPACE}/aqa-tests/jck/splitter") {
        def JDK_VERSION= params.JDK_VERSION
        if (JDK_VERSION == "8") {
            JDK_VERSION = "8d"
        } else if (JDK_VERSION == "11"){
             JDK_VERSION = "11a"
        } 
        def TESTS_MAP = [
            'ANNOT': ['GROUP' : 5,],
            'CLSS' : ['GROUP' : 10,],
            'CONV' : ['GROUP' : 5,],
            'DASG' : ['GROUP' : 5,],
            'EXPR' : ['GROUP' : 11,],
            'INTF' : ['GROUP' : 5,],
            'LMBD' : ['GROUP' : 5,],
            'NAME' : ['GROUP' : 5,],
            'TYPE' : ['GROUP' : 5,],
            'STMT' : ['GROUP' : 5,],
            'VERIFIER' : ['GROUP' : 4,],
        ]
        def TARGET_TO_SPLIT = "${WORKSPACE}/test/JCK-compiler-${JDK_VERSION}/tests/lang"
        def SCRIPT=""
        def COMMENT=""
        def PR_NEEDED = false
        def testClasstList = []
        def mkFileName = "${WORKSPACE}/aqa-tests/jck/jck.mk"
        TESTS_MAP.each { key, value ->
            //no verifier group available for JDK8
            if (key == "VERIFIER" && JDK_VERSION == "8d"){
                echo "No need to create PR for --- $key"
            } else if (value.containsKey('GROUP')) {
                //def testsValue = value['TESTS']
                def groupValue = value['GROUP']
                //echo "Calling splitter.sh for TESTS: $key and GROUP:$groupValue"
                // Call the test.sh script here, passing testsValue as an argument
                TARGET="${TARGET_TO_SPLIT}/${key}"
                if (key == "VERIFIER"){
                    TARGET="${WORKSPACE}/test/JCK-runtime-${JDK_VERSION}/tests/vm/verifier/instructions"
                }
                SCRIPT = "./splitter.sh ${TARGET} ${groupValue}"
                if (key == "CLSS"){
                    key="CLASS"
                }
                def logFileName = "${key}.log"
                def EXITCODE = sh(script: "${SCRIPT} > ${logFileName}", returnStatus: true)
                
                //echo "EXITCODE in splitter =${EXITCODE}"
                //sh "cat ${logFileName}"
                
                def lastLine = null
                // Read the last line starting with COMPILER_LANG_ANNOT_TESTS_GROUP from logFileName.log
                def logFileContents = readFile(file: logFileName).trim().split('\n')
                for (int i = logFileContents.size() - 1; i >= 0; i--) {
                    def line = logFileContents[i]
                    if (line.startsWith("COMPILER_LANG_${key}_TESTS_GROUP") || line.startsWith("VERIFIER_INSTRUCTIONS_TESTS_GROUP") ) {
                        lastLine = line
                        break
                    }
                }
                // Check if the last line is present in jck.mk
                def mkFileContents = readFile(file: mkFileName).trim()
                //echo "Last test group in ${logFileName}: ${lastLine}"
                if (lastLine && mkFileContents.contains(lastLine)) {
                    //echo "The line is present in $mkFileName"
                    echo "No need to create PR for --- $key"
                } else {
                    //echo "The line is not present in $mkFileName"
                    echo "We need to create PR for --- $key"
                    testClasstList.add(key)
                    PR_NEEDED=true
                }
            }
        }
        if (PR_NEEDED){
            script_pr=updateJCKmkFile(testClasstList,script_pr)
            COMMENT=" Splitter.sh resulted in new test groups.\\r\\n We need to create PR to update jck.mk file for below test group\\r\\n " + testClasstList.join(", ")
            echo "${testClasstList}"
        } else {
            COMMENT =" No need to create PR to update jck.mk file."
        }
        createComment(COMMENT, number)
        return script_pr
    }
}

def getJavaSDK(){
        def JDK_VERSION_OPTION = env.JDK_VERSION ? "-j ${env.JDK_VERSION}" : ""
       // def JDK_IMPL_OPTION = env.JDK_IMPL ? "-i ${env.JDK_IMPL}" : ""
        def CUSTOMIZED_SDK_OPTION = "-c ${params.CUSTOMIZED_SDK}"
        def CLONE_OPENJ9_OPTION = "--clone_openj9 false"
        //echo "getJavaSDK"
        //-r $SDK_RESOURCE , JDK_IMPL_OPTION not passing as default is nightly
        def PLATFORM_OPTION = "-p x86-64_linux"
        def GET_SH_CMD = "./get.sh -s `pwd`/.. $PLATFORM_OPTION  $JDK_VERSION_OPTION $CUSTOMIZED_SDK_OPTION $CLONE_OPENJ9_OPTION "// ${OPENJ9_REPO_OPTION} ${OPENJ9_BRANCH_OPTION} ${OPENJ9_SHA_OPTION} ${TKG_REPO_OPTION} ${TKG_BRANCH_OPTION}
        dir("${WORKSPACE}/aqa-tests") {
            if (params.CUSTOMIZED_SDK_URL_CREDENTIAL_ID) {
			// USERNAME and PASSWORD reference with a withCredentials block will not be visible within job output
			withCredentials([usernamePassword(credentialsId: "${params.CUSTOMIZED_SDK_URL_CREDENTIAL_ID}", usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
				sh "$GET_SH_CMD"
			}
		} else {
			sh "$GET_SH_CMD"
		}
            // sshagent(credentials:["${params.USER_CREDENTIALS_ID}"], ignoreMissing: true) {
            //     sh "$GET_SH_CMD"
	        // }
        }
}



def udpateFolderCheck(){

    def ADOPTIUM_GIT_USER = params.ADOPTIUM_USER ?: ""

    if (ADOPTIUM_GIT_USER == "" || ADOPTIUM_GIT_USER == null){
        echo "No PR will be created as ADOPTIUM_GIT_USER value is null. "
        return false
    } else {
        dir("${WORKSPACE}/aqa-tests/jck") {
            sshagent(credentials:["${params.ADOPTIUM_SSH_CREDS}"], ignoreMissing: true){
                try {
                        sh """
                        git remote remove origin
                        git remote remove upstream
                        """
                } catch (Exception e) {
                        // Handle the error here, but do not throw it
                        echo "Error removing remote: ${e.message}"
                }
                def origin ="git@github.com:${ADOPTIUM_GIT_USER}/aqa-tests.git"
                def upstream ="git@github.com:adoptium/aqa-tests.git"
                sh """
                    git remote add origin ${origin}
                    git remote add upstream ${upstream}
                    git fetch upstream
                    git checkout -b test
                    git config --global user.email "${ADOPTIUM_GIT_USER}@in.ibm.com"
                    git config --global user.name "${ADOPTIUM_GIT_USER}"
                """
                //echo "SCRIPT_PR in udpateFolderCheck -- $SCRIPT_PR"
                //SCRIPT_PR=true
                def sourceFilePath = createFile()
                //def sourceFilePath = "aqa-tests/jck/jck_target_folder_check/test.log" //createFile() //change to aqa-tests/jck/jck_target_folder_check/test.log
                def modifiedFiles = []
                //def sourceFilePath = logFile
                def sourceFileContent = readFile(file: sourceFilePath)
                def pattern = /(?s)(New test folder detected:(.*?)<\/test>)/
                def matches = (sourceFileContent =~ pattern)
                def compilerMap = [
                    '/lang': 'compiler.lang/playlist.xml',
                    '/api': 'compiler.api/playlist.xml'
                    // Add other mappings as needed
                ]
                def runtimeMap = [
                    '/lang': 'runtime.lang/playlist.xml',
                    '/api': 'runtime.api/playlist.xml',
                    '/vm': 'runtime.vm/playlist.xml',
                    '/xml_schema': 'runtime.xml_schema/playlist.xml'
                    // Add other mappings as needed
                ]
                def devtoolsMap = [
                    '/java2schema': 'devtools.java2schema/playlist.xml',
                    '/jaxws': 'devtools.jaxws/playlist.xml',
                    '/schema_bind': 'devtools.schema_bind/playlist.xml',
                    '/schema2java': 'devtools.schema2java/playlist.xml',
                    '/xml_schema': 'devtools.xml_schema/playlist.xml'
                    // Add other mappings as needed
                ]
                matches.each { match ->
                    def fullMatch = match[0]
                    def pathMatch = fullMatch =~ /New test folder detected:\s*(\S+)/
                    def fullPath = pathMatch[0][1].trim()
                    // Extract just the directory path (e.g., /lang or /api)
                    def path = fullPath =~ /\/(\w+)\//
                    if (path.size() > 0) {
                        path = "/${path[0][1]}"
                    }
                    // Check if a target file path is defined for the path
                    def targetFilePath=""
                    if (fullMatch.contains("COMPILER")) {
                        targetFilePath = compilerMap[path]
                    } else if(fullMatch.contains("RUNTIME")) {
                        targetFilePath = runtimeMap[path]
                    } else  {
                        targetFilePath = devtoolsMap[path]
                    }

                    if (targetFilePath) {
                        // Read the current target file content
                        def targetFileContent = readFile(file: targetFilePath)
                        // Extract the content from <test> to </test> in the match block
                        def matcher = fullMatch =~ /(?s)(<test>(.*?)<\/test>)/
                        //def testContent=""
                        if (matcher.find()) {
                            //testContent = matcher.group(0)
                            // Append the test block (excluding "New test folder detected" line) to the target file content
                            def updatedTargetContent = targetFileContent.replace('</playlist>', "\t${matcher.group(0)}\n</playlist>")
                            // Write the updated content back to the target XML file
                            //echo " testContent ---  ${testContent}"
                            //echo " updatedTargetContent ---  $updatedTargetContent"
                            writeFile(file: targetFilePath, text: updatedTargetContent)
                            echo "Updated target XML file: $targetFilePath"
                            modifiedFiles.add(targetFilePath)
                            // sh """
                            // git diff targetFilePath
                            // """
                        } else {
                            echo "No match found."
                        }
                    } else {
                        echo "No target file mapping found for path: $path"
                    }
                }
                def filesToStage = modifiedFiles.join(' ')
                def gitAddCommand = "git add ${filesToStage}"

                sh(script: gitAddCommand)
                sh """
                    git commit -m "update folder check"
                    git push origin test
                """
            }
        }
    return true
    }
}

def updateJCKmkFile(testClasstList,SCRIPT_PR){
    def ADOPTIUM_GIT_USER = params.ADOPTIUM_USER ?: ""

    if (ADOPTIUM_GIT_USER == "" || ADOPTIUM_GIT_USER == null){
        echo "No PR will be created as ADOPTIUM_GIT_USER value is null. "
        return false
    } else {
        sshagent(credentials:["${params.ADOPTIUM_SSH_CREDS}"], ignoreMissing: true){
            if (!SCRIPT_PR){  
                SCRIPT_PR=true 
                try {
                    sh """
                        git remote remove origin
                        git remote remove upstream
                    """
                } catch (Exception e) {
                    echo "Error removing remote: ${e.message}"
                }
                def origin ="git@github.com:${ADOPTIUM_GIT_USER}/aqa-tests.git"
                def upstream ="git@github.com:adoptium/aqa-tests.git"
                //git checkout -b personal-branch upstream/main
                sh """
                    git remote add origin ${origin}
                    git remote add upstream ${upstream}
                    git fetch upstream
                    git checkout -b test
                    git config --global user.email "${ADOPTIUM_GIT_USER}@in.ibm.com"
                    git config --global user.name "${ADOPTIUM_GIT_USER}"
                """
            }
            def targetFilePath = "${WORKSPACE}/aqa-tests/jck/jck.mk"
            JDK_VERSION = params.JDK_VERSION
            def blockCondition = "ifeq (${JDK_VERSION}, \$(JDK_VERSION))"

            sshagent(credentials:["${params.ADOPTIUM_SSH_CREDS}"], ignoreMissing: true){
                testClasstList.each{ test ->
                    def sourceFilePath = "${test}.log"
                    echo "file --- ${sourceFilePath}"
                    //sh "cat ${sourceFilePath}"
                    // Read all lines from the source file containing "="
                    def sourceLines = readFile(file: sourceFilePath).readLines().findAll { it.contains('=') }

                    // Read the target file into a list
                    def targetLines = readFile(file: targetFilePath).readLines()

                    // Iterate through the source lines
                    sourceLines.each { sourceLine ->
                        // Split the source line by "="
                        def sourceParts = sourceLine.split('=')
                        def sourceKey = sourceParts[0]
                        // Initialize a flag to determine if we have replaced a line
                        def lineReplaced = false
                        def insideBlock = false
                        def keywords = ["COMPILER", "VERIFIER", "RUNTIME"]
                        // Iterate through the target lines
                        def updatedTargetLines = targetLines.collect { line ->
                            def lineContainsKeywords =keywords.any { keyword -> line.contains(keyword) }
                            if (line.contains(blockCondition)) {
                                insideBlock = true
                                line
                            }else if (!(line.isEmpty() ||line.trim().isEmpty()) && !lineContainsKeywords) {
                                insideBlock = false
                                line
                            }else if (insideBlock && !lineReplaced && line.contains(sourceKey)) {
                                    //println "source key -- ${sourceKey}"
                                    lineReplaced = true
                                    //println sourceLine
                                    "   ${sourceLine}"
                            }else {
                                    line
                            }
                        }
                        // Update the target lines for the next source line
                        targetLines = updatedTargetLines
                    }
                    // Write the updated target lines back to the target file
                    writeFile(file: targetFilePath, text: targetLines.join('\n'))
                }
                echo "jck.mk --- ${targetFilePath}"
                def gitAddCommand = "git add ${targetFilePath}"
                sh(script: gitAddCommand)

                sh """
                    git commit -m "update jck.mk"
                    git push origin test
                """
            }
        }
    return true
    }
}

def createPRForScripts(number) {

    def ADOPTIUM_GIT_USER = params.ADOPTIUM_USER ?: ""
    if (ADOPTIUM_GIT_USER == ""){
        echo "No PR will be created as ADOPTIUM_GIT_USER value is null. "
    } else {
        withCredentials([
                string(credentialsId: "${params.ADOPTIUM_GIT_CREDENTIALS}",variable: 'ADOPTIUM_GIT_TOKEN')
            ]){
            dir("${WORKSPACE}/aqa-tests") {
                sshagent(credentials:["${params.ADOPTIUM_SSH_CREDS}"], ignoreMissing: true){
                title="Update jck.mk and playlist.xml file"
                body="Creating PR to update jck.mk and playlist file"
                echo " Creating PR for jck.mk and playlist.xml file"
                url="https://api.github.com/repos/${ADOPTIUM_GIT_USER}/aqa-tests/pulls"
                //-d "{"title":"$title","body":"$body","head":\"KapilPowar:test\",\"base\":\"jcksync-copy"}" \
                def CURL_COMMAND = """
                                    curl -X POST "${url}" \\
                                        -H "Authorization: token \"\$ADOPTIUM_GIT_TOKEN\"" \\
                                        -H "Content-Type: application/json" \\
                                        -d '{
                                            "title": "${title}",
                                            "body": "${body}",
                                            "head": "${ADOPTIUM_GIT_USER}:test",
                                            "base": "jcksync-copy"
                                        }'
                                """
                def response = sh(script: CURL_COMMAND, returnStdout: true)
                def matcher = (response =~ /"number":\s*(\d+)/)
                def PR = matcher ? matcher[0][1] : null
                echo "PR_NUMBER = ${PR}"
                PR_URL= "https://github.com/${ADOPTIUM_GIT_USER}/aqa-tests/pull/"
                COMMENT=" PR #[${(PR)}](${PR_URL}${(PR)})  is created with changes in jck.mk and playlist.xml file .. "
                createComment(COMMENT, number)
                }
            }
        }
    }
}

def createComment(Comment,Number) {
    withCredentials([
        string(credentialsId: "${params.GIT_CREDENTIALS}",variable: 'GIT_CREDENTIALS')
    ]) {
        def DOMAIN = params.JCK_GIT_REPO.split(/[@:]/)
        def REPO = DOMAIN[2].split('\\.')
        def COMMENT_URL="https://${DOMAIN[1]}/api/v3/repos/${REPO[0]}/issues/${Number}/comments"
        def PR_URL="https://${DOMAIN[1]}/${REPO[0]}/pull/${Number}"
        echo ("${Comment}")
        def CURL_COMMAND = """
            curl -X POST -H "Authorization: token \"\$GIT_CREDENTIALS\"" \\
            -d '{
            "body":"${Comment}"
            }' "$COMMENT_URL"
        """
        def STATUS = sh(script: CURL_COMMAND, returnStatus: true, returnStdout: true)
        if (STATUS == 0) {
            echo ("Comment added successfully to PR ${PR_URL} ")
        } else {
            error ("Failed to add a comment to PR ${PR_URL} ")
        }
    }
}

def extractNumber(output) {
    def lines = output.readLines()
    for (line in lines) {
        if (line =~ /PR_Number=(\d+)/) {
            return line.replaceAll(/.*PR_Number=(\d+).*/, '$1')
        }
    }
    return 0
}

def createFile(){
    def logFile = "test1.log"
    def fileContent = """
    Cleaning up generated target list..
Done!
--------------------------------------------------------
     Cross-checking test folders under: compiler       
--------------------------------------------------------
New test folder detected: ./lang/ANNOT1 | Please add target: jck-compiler-lang-ANNOT1
	<test>
		<testCaseName>jck-compiler-lang-ANNOT1</testCaseName>
		<variations>
			<variation>NoOptions</variation>
		</variations>
		<command>\$(GEN_JTB_GENERIC) tests=lang/ANNOT1 testsuite=COMPILER; \\
		\$(EXEC_COMPILER_TEST); \\
		\$(TEST_STATUS); \\
		\$(GEN_SUMMARY_GENERIC) tests=lang/ANNOT1 testsuite=COMPILER
		</command>
		<levels>
			<level>extended</level>
		</levels>
		<groups>
			<group>jck</group>
		</groups>
	</test>
New test folder detected: ./lang/STMT1 | Please add target: jck-compiler-lang-STMT1
	<test>
		<testCaseName>jck-compiler-lang-STMT1</testCaseName>
		<variations>
			<variation>NoOptions</variation>
		</variations>
		<command>\$(GEN_JTB_GENERIC) tests=lang/STMT1 testsuite=COMPILER; \\
		\$(EXEC_COMPILER_TEST); \\
		\$(TEST_STATUS); \\
		\$(GEN_SUMMARY_GENERIC) tests=lang/STMT1 testsuite=COMPILER
		</command>
		<levels>
			<level>extended</level>
		</levels>
		<groups>
			<group>jck</group>
		</groups>
	</test>
Total new folders detected : 2
--------------------------------------------------------
     Cross-checking test folders under: runtime       
--------------------------------------------------------
New test folder detected: ./lang/ARR1 | Please add target: jck-runtime-lang-ARR1
	<test>
		<testCaseName>jck-runtime-lang-ARR1</testCaseName>
		<variations>
			<variation>NoOptions</variation>
		</variations>
		<command>\$(GEN_JTB_GENERIC) tests=lang/ARR1 testsuite=RUNTIME; \\
		\$(EXEC_RUNTIME_TEST); \\
		\$(TEST_STATUS); \\
		\$(GEN_SUMMARY_GENERIC) tests=lang/ARR1 testsuite=RUNTIME
		</command>
		<levels>
			<level>extended</level>
		</levels>
		<groups>
			<group>jck</group>
		</groups>
	</test>
New test folder detected: ./api/test | Please add target: jck-runtime-api-test
	<test>
		<testCaseName>jck-runtime-api-test</testCaseName>
		<variations>
			<variation>NoOptions</variation>
		</variations>
		<command>\$(GEN_JTB_GENERIC) tests=api/test testsuite=RUNTIME; \\
		\$(EXEC_RUNTIME_TEST); \\
		\$(TEST_STATUS); \\
		\$(GEN_SUMMARY_GENERIC) tests=api/test testsuite=RUNTIME
		</command>
		<levels>
			<level>extended</level>
		</levels>
		<groups>
			<group>jck</group>
		</groups>
	</test>
New test folder detected: ./xml_schema/sunData1 | Please add target: jck-devtools-xml_schema-sunData1
	<test>
		<testCaseName>jck-devtools-xml_schema-sunData1</testCaseName>
		<variations>
			<variation>NoOptions</variation>
		</variations>
		<command>\$(GEN_JTB_GENERIC) tests=xml_schema/sunData1 testsuite=DEVTOOLS; \\
		\$(EXEC_DEVTOOLS_TEST); \\
		\$(TEST_STATUS); \\
		\$(GEN_SUMMARY_GENERIC) tests=xml_schema/sunData1 testsuite=DEVTOOLS
		</command>
		<levels>
			<level>extended</level>
		</levels>
		<groups>
			<group>jck</group>
		</groups>
		<versions>
			<version>8</version>
		</versions>
	</test>
Total new folders detected : 2
Wed Sep 20 18:43:17 IST 2023
Total process took ~ 1 seconds.
"""
writeFile(file: logFile, text: fileContent)
return logFile
}
